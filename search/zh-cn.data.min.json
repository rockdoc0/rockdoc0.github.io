[{"id":0,"href":"/zh-cn/usage/why-redrock/","title":"为什么选择Redrock Postgres？","parent":"使用介绍","content":"为什么选择Postgres？     Postgres是一个高级关系数据库管理系统，支持SQL标准的扩展子集，包括事务，外键，子查询，触发器，用户定义的类型和函数。简而言之，Postgres在数据一致性、稳定性、高性能、功能丰富、开发人员友好等方面已经获得了良好的声誉。\n为什么选择Redrock Postgres？     尽管Postgres在大多数场景下表现良好，但仍有一些需要改进的地方，这正是Redrock Postgres为实现的目标：\n 更好地控制膨胀。Redrock Postgres将通过在常见情况下允许就地更新以及在执行删除或非就地更新的事务提交后立即重用空间来防止膨胀。简而言之，只要有可能，我们就会从一开始就避免产生膨胀。 通过避免重写堆页，并通过在不更新每个索引的情况下执行相关索引列的更新，减少写入放大。 通过收缩元组头部来减小元组大小。 标记删除索引记录：这将允许在索引列修改时进行就地更新，而且还可以去除那个用来进行零散的空间回收操作的垃圾清理进程。此外，索引扫描计划将会执行得更加稳定。 语句级回滚，同主流关系数据库保持兼容的事务处理行为。 没有vacuum，没有冻结，也没有事务号翻转的问题。  "},{"id":1,"href":"/zh-cn/installation/windows/","title":"Windows 安装指导","parent":"安装指导","content":"要使用图形安装向导执行安装，您必须具有超级用户或管理员权限。\n以下部分将引导您完成在 Windows 主机上安装 PostgreSQL 的过程。\n要启动安装向导，请确保有足够的权限，然后双击安装程序图标。如果出现提示，请提供密码。\n请注意，在某些版本的Windows中，要使用管理员权限调用安装程序，您需要右键单击安装程序图标，然后从上下文菜单中选择以管理员身份运行。\n将打开Redrock12 安装欢迎窗口，单击下一步继续。\n    图 1: Redrock 12 安装欢迎窗口    将打开选择安装位置窗口。接受默认安装目录，或者指定其他可用位置，然后单击下一步继续。\n    图 2: 选择安装位置对话框    单击下一步继续。\n将打开选择数据目录窗口。接受默认的数据存储位置，或者指定要其他可用位置用于存储数据文件。\n    图 3: 选择数据存储位置对话框    单击下一步继续。\n将打开服务器选项窗口。\n    图 4: 服务器选项对话框    PostgreSQL 使用端口字段来指定服务器应侦听的端口号。默认侦听器端口为5432。\n使用区域字段指定新数据库群集将使用的区域设置。默认是操作系统区域设置。\n使用管理员用户字段指定数据库管理员用户名称。默认管理员用户名是postgres。\n使用管理员密码字段指定数据库管理员密码。输入的密码应符合足够的复杂性。在管理员密码字段中输入密码，并在确认字段中确认密码后。\n单击下一步继续。\n    图 5: 调整配置参数对话框    调整配置参数对话框将指导您通过设置一些重要的配置参数来优化服务器性能。您可以让安装程序自动调整配置参数，然后单击下一步继续。\n    图 6: 选择开始菜单文件夹    在安装过程中，安装向导会通过一系列进度条确认PostgreSQL的安装进度。\n    图 7: 安装进度显示窗口    当出现安装程序结束窗口时，恭喜您！请单击完成以完成 PostgreSQL 安装。\n    图 8: 安装程序结束窗口    "},{"id":2,"href":"/zh-cn/usage/getting-started/","title":"开始上手","parent":"使用介绍","content":"   安装 架构基础 访问数据库 下一步是什么？      安装     自然，在你能开始使用Redrock Postgres之前， 你必须安装它。有可能PostgreSQL已经安装到你的机器上了， 因为它可能包含在你的操作系统的发布里， 或者是系统管理员已经安装了它。如果是这样的话， 那么你应该从操作系统的文档或者你的系统管理员那里获取有关如何访问PostgreSQL的信息。\n如果你不清楚PostgreSQL是否已经安装， 或者不知道你能否用它（已经安装的）做自己的实验，那么你就可以自己安装。 这么做并不难，并且是一次很好的练习。\n如果你准备自己安装Redrock Postgres， 那么请参考安装指导以获取安装的有关信息， 安装之后再回到这个指导手册来。一定要记住要尽可能遵循有关设置合适的环境变量章节里的信息。\n如果你的站点管理员没有按照缺省的方式设置各项相关参数， 那你还有点额外的活儿要干。比如，如果数据库服务器机器是一个远程的机器， 那你就需要把PGHOST环境变量设置为数据库服务器的名字。环境变量PGPORT也可能需要设置。总而言之就是： 如果当你试着启动一个应用而该应用报告说不能与数据库建立联接时， 你应该马上与你的数据库管理员联系，如果你就是管理员， 那么你就要参考文档以确保你的环境变量得到正确的设置。 如果你不理解随后的几段，那么先阅读下一节。\n架构基础     在我们继续之前，你应该先了解PostgreSQL的系统架构。 对PostgreSQL的部件之间如何相互作用的理解将会使本节更易理解。\n在数据库术语里，PostgreSQL使用一种客户端/服务器的模型。一次PostgreSQL会话由下列相关的进程（程序）组成：\n 一个服务器进程，它管理数据库文件、接受来自客户端应用与数据库的联接并且代表客户端在数据库上执行操作。 该数据库服务器程序叫做postgres。 那些需要执行数据库操作的用户的客户端（前端）应用。 客户端应用可能本身就是多种多样的：可以是一个面向文本的工具， 也可以是一个图形界面的应用，或者是一个通过访问数据库来显示网页的网页服务器，或者是一个特制的数据库管理工具。 一些客户端应用是和 PostgreSQL发布一起提供的，但绝大部分是用户开发的。  和典型的客户端/服务器应用（C/S应用）一样，这些客户端和服务器可以在不同的主机上。 这时它们通过 TCP/IP 网络联接通讯。 你应该记住的是，在客户机上可以访问的文件未必能够在数据库服务器机器上访问（或者只能用不同的文件名进行访问）。\nPostgreSQL服务器可以处理来自客户端的多个并发请求。 因此，它为每个连接启动（“forks”）一个新的进程。 从这个时候开始，客户端和新服务器进程就不再经过最初的 postgres进程的干涉进行通讯。 因此，主服务器进程总是在运行并等待着客户端联接， 而客户端和相关联的服务器进程则是起起停停（当然，这些对用户是透明的。我们介绍这些主要是为了内容的完整性）。\n访问数据库     一旦你创建了数据库，你就可以通过以下方式访问它：\n 运行PostgreSQL的交互式终端程序，它被称为psql， 它允许你交互地输入、编辑和执行SQL命令。 使用一种已有的图形化前端工具，比如pgAdmin或者带ODBC或JDBC支持的办公套件来创建和管理数据库。这种方法在这份教程中没有介绍。 使用多种绑定发行的语言中的一种写一个自定义的应用。这些可能性在第 IV 部分中将有更深入的讨论。  你可能需要启动psql来试验本教程中的例子。 你可以用下面的命令为postgres数据库激活它：\n$ psql postgres 如果你不提供数据库名字，那么它的缺省值就是你的用户账号名字。\n在psql中，你将看到下面的欢迎信息：\npsql (12.1) Type \u0026#34;help\u0026#34; for help. postgres=\u0026gt; 最后一行也可能是：\npostgres=# 这个提示符意味着你是数据库超级用户，最可能出现在你自己安装了 PostgreSQL实例的情况下。 作为超级用户意味着你不受访问控制的限制。 对于本教程的目的而言， 是否超级用户并不重要。\npsql打印出的最后一行是提示符，它表示psql正听着你说话，这个时候你就可以敲入 SQL查询到一个psql维护的工作区中。试验一下下面的命令：\npostgres=\u0026gt; SELECT version(); version ------------------------------------------------------------------------------------------ PostgreSQL 12.1 on x86_64-pc-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-bit (1 row) postgres=\u0026gt; SELECT current_date; date ------------ 2016-01-07 (1 row) postgres=\u0026gt; SELECT 2 + 2; ?column? ---------- 4 (1 row) psql程序有一些不属于SQL命令的内部命令。它们以反斜线开头，“\\”。 欢迎信息中列出了一些这种命令。比如，你可以用下面的命令获取各种PostgreSQL的SQL命令的帮助语法：\npostgres=\u0026gt; \\h 要退出psql，输入：\npostgres=\u0026gt; \\q psql将会退出并且让你返回到命令行shell。 （要获取更多有关内部命令的信息，你可以在psql提示符上键入\\?。） psql的完整功能在psql中有文档说明。在这份文档里，我们将不会明确使用这些特性，但是你自己可以在需要的时候使用它们。\n下一步是什么？     还有很多东西要发现。 要获取更多信息，请参阅 PostgreSQL 文档。\n"},{"id":3,"href":"/zh-cn/usage/","title":"使用介绍","parent":"欢迎访问红石数据库文档","content":""},{"id":4,"href":"/zh-cn/installation/","title":"安装指导","parent":"欢迎访问红石数据库文档","content":"目录\n   Windows 安装指导      Red Hat/CentOS 安装指导      Debian 安装指导      本章接下来的部分描述了如何安装您选择的发行版。\n"},{"id":5,"href":"/zh-cn/installation/redhat/","title":"Red Hat/CentOS 安装指导","parent":"安装指导","content":"   安装软件包  安装检查 安装 Redrock Postgres   安装设置  数据目录 更改数据目录 初始化数据 设置开机启动   服务器控制 安装后配置调整      安装软件包     安装检查     使用您的 root 帐户登录到主机，并运行以下命令来查询已安装的软件包，确保没有安装过 postgresql 相关的软件包：\n# rpm -qa | grep postgresql 安装 Redrock Postgres     下载 Red Hat 或 CentOS 的安装包，并执行以下命令进行安装：\n# tar xf redrock-12.1-1.el8.x86_64-bundle.tar # cd redrock-12.1-1.el8.x86_64-bundle # rpm -ivh redrock-12.1-1.el8.x86_64.rpm redrock-libs-12.1-1.el8.x86_64.rpm redrock-server-12.1-1.el8.x86_64.rpm 您还可以根据您的需要安装其他软件包。\n安装设置     安装软件包后，需要初始化和配置数据库。\n在下面的命令中，version 的值表示 PostgreSQL 的主版本号，例如：12\n数据目录     PostgreSQL 数据目录包含数据库的所有数据文件。环境变量 PGDATA 用于指定数据目录路径。\n默认数据目录为：\n/var/lib/pgsql/\u0026lt;version\u0026gt;/data 例如：\n/var/lib/pgsql/12/data 更改数据目录     如果不想使用默认的数据目录，可以进入到一个自定义的挂载目录（例如：/u01），然后创建一个 postgres 用户为拥有者的文件夹 pgdata ：\n# cd /u01 # mkdir pgdata # chown postgres:postgres pgdata 然后，编辑 postgresql 服务：\n# systemctl edit postgresql-12.service 进入到自定义的数据目录，该目录应该具有主机中大部分的可用磁盘空间，复制该目录路径并粘贴到服务文件中：\n[Service] Environment=PGDATA=/u01/pgdata 初始化数据     执行类似如下的命令，在 PGDATA 中初始化数据库：\n# /usr/pgsql-\u0026lt;version\u0026gt;/bin/postgresql-\u0026lt;version\u0026gt;-setup initdb 对于版本 12，请使用：\n# /usr/pgsql-12/bin/postgresql-12-setup initdb 设置开机启动     如果您希望 PostgreSQL 在操作系统开机启动时自动运行，请执行以下操作：\n# systemctl enable postgresql-12.service 服务器控制     要控制数据库服务，请使用：\n# systemctl \u0026lt;command\u0026gt; postgresql-12.service 其中的 command 可以为:\n enable : 启用开机启动 start : 启动数据库 stop : 停止数据库 restart : 重启数据库; 主要用于重要参数的变更生效 reload : 在数据库运行过程中更新配置参数  例如，要控制版本 12 的数据库服务，请使用：\n# systemctl enable postgresql-12.service # systemctl start postgresql-12.service 安装后配置调整     修改数据目录下的 pg_hba.conf 文件，以定义从网络中其他主机访问 PostgreSQL 服务器使用的访问控制策略，修改IPv4网络访问控制策略：从 indent 更改为 md5，从本机地址 127.0.0.1 更改为接受所有主机访问请求。找到下面行：\n# IPv4 local connections: host all all 127.0.0.1/32 ident 并将其更改为：\n# IPv4 local connections: host all all 0.0.0.0/0 md5 修改数据目录下的 postgresql.conf 文件，通过取消注释以下参数行并设置参数值为 * 而不是 localhost 来允许来自所有主机的访问连接：\nlisten_addresses = \u0026#39;*\u0026#39; 重启数据库服务以更新配置参数：\n# systemctl restart postgresql-12.service 在生产环境中，还应设置 TLS 安全通信，并且应考虑配置数据复制或基于快照的备份。有关这些配置，请参阅 PostgreSQL 在线文档。\n"},{"id":6,"href":"/zh-cn/features/","title":"基础特性","parent":"欢迎访问红石数据库文档","content":""},{"id":7,"href":"/zh-cn/installation/debian/","title":"Debian 安装指导","parent":"安装指导","content":"   安装软件包  安装准备 安装 Redrock Postgres   服务器控制 安装后配置调整      安装软件包     安装准备     使用您的 root 帐户登录到主机，然后运行以下命令来安装依赖包：\n# apt install postgresql-common postgresql-client-common 安装 Redrock Postgres     下载 Debian 的安装包，并执行以下命令进行安装：\n# tar xf redrock-12.1-1.debian10.x86_64-bundle.tar # cd redrock-12.1-1.debian10.x86_64-bundle # dpkg -i libpq5_12.1-1_amd64.deb redrock-client_12.1-1_amd64.deb redrock_12.1-1_amd64.deb 您还可以根据您的需要安装其他软件包。\n服务器控制     要控制数据库服务，请使用：\n# systemctl \u0026lt;command\u0026gt; postgresql 其中的 command 可以为:\n enable : 启用开机启动 start : 启动数据库 stop : 停止数据库 restart : 重启数据库; 主要用于重要参数的变更生效 reload : 在数据库运行过程中更新配置参数  安装后配置调整     修改配置目录（默认值：/etc/postgresql/12/main/）中的pg_hba.conf文件，以定义从网络中其他主机访问 PostgreSQL 服务器使用的访问控制策略，修改IPv4网络访问控制策略：从 indent 更改为 md5，从本机地址 127.0.0.1 更改为接受所有主机访问请求。找到下面行：\n# IPv4 local connections: host all all 127.0.0.1/32 ident 并将其更改为：\n# IPv4 local connections: host all all 0.0.0.0/0 md5 修改配置目录（默认值：/etc/postgresql/12/main/ ）中的 postgresql.conf 文件，通过取消注释以下参数行并设置参数值为 * 而不是 localhost 来允许来自所有主机的访问连接：\nlisten_addresses = \u0026#39;*\u0026#39; 重启数据库服务以更新配置参数：\n# systemctl restart postgresql 在生产环境中，还应设置 TLS 安全通信，并且应考虑配置数据复制或基于快照的备份。有关这些配置，请参阅 PostgreSQL 在线文档。\n"},{"id":8,"href":"/zh-cn/usage/configuration/","title":"参数配置","parent":"使用介绍","content":"在PostgreSQL的基础上，Redrock Postgres修改或新增的服务器配置选项的概述。\n   资源消耗 预写式日志 运行时统计信息 自动分析      资源消耗     这些设置用于控制数据库服务器的资源消耗。\n  threaded_execution (boolean)\n控制是否启用多线程 Postgres 模型。在 Redrock Postgres 中，多线程 Postgres 模型使 UNIX 和 Linux 上的 Postgres 进程能够作为操作系统线程在单独的地址空间中运行。\n默认情况下，Windows上与会话相关的后端进程始终使用线程执行;其余的后台进程作为操作系统进程运行。因此，“Postgres进程”并不总是等同于“操作系统进程”。\n  预写式日志     有几个WAL相关的配置参数会影响数据库性能。\n  data_checksums (boolean)\n控制是否在写数据块时计算校验和（根据块中存储的所有字节计算的数字），并在将数据块写入磁盘时将校验和存储在每个数据块的页头中。如果此参数为on，并且块的最后一次写入存储了校验和，那么在读取块时，校验和将被验证。此外，Postgres还会在应用更新/删除语句中的更改之前验证校验和，并在应用更改后重新计算校验和。此外，Postgres在将每个WAL记录写入磁盘之前都会为其提供校验和。\n如果此参数设置为off，则关闭数据校验和。\n校验和允许Postgres检测由底层磁盘、存储系统或I/O系统引起的损坏。打开数据校验和仅导致额外1%到2%的开销。\n  运行时统计信息     这些参数控制服务器范围的统计数据收集特性。当统计收集被启用时，被产生的数据可以通过pg_stat和pg_statio系统视图族访问。详见运行统计视图。\n  track_wait_events (boolean)\n启用有关每个会话中发生的等待事件的信息的收集，包括发生的等待次数和耗时信息。该参数默认开启。注意即使被启用，这些信息也不是对所有用户可见，只有超级用户和拥有报告信息的会话的用户可见，因此它不会表现为一个安全风险。只有超级用户可以更改这个设置。\n  自动分析     这些设置控制自动分析特性的行为。详情请参考 第 24.1.6 节。注意很多这些设置可以被针对每个表的设置所覆盖，请见存储参数。\n  autoanalyze (boolean)\n控制服务器是否运行自动分析启动器后台进程。默认为开启， 不过要自动分析正常工作还需要启用track_counts。 该参数只能在postgresql.conf文件或服务器命令行中设置， 不过，通过更改表存储参数可以为表禁用自动分析。\n  log_autoanalyze_min_duration (integer)\n如果自动分析运行至少该值所指定的时间量，被自动分析执行的每一个动作都会被日志记录。 将该参数设置为0会记录所有的自动分析动作。 -1（默认值）将禁用对自动分析动作的记录。 如果指定值时没有单位，则以毫秒为单位。 例如，如果你将它设置为250ms，则所有运行250ms或更长时间的自动分析将被记录。此外，当该参数被设置为除-1外的任何值时， 如果一个自动分析动作由于一个锁冲突或者被并发删除的关系而被跳过，将会为此记录一个消息。 开启这个参数对于追踪自动分析活动非常有用。这个参数只能在 postgresql.conf文件或者服务器命令行中设置。但是可以通过更改表的存储参数为个别表覆盖这个设置。\n  autoanalyze_max_workers (integer)\n指定能同时运行的自动分析进程（除了自动分析启动器之外）的最大数量。默认值为3。该参数只能在服务器启动时设置。\n  autoanalyze_naptime (integer)\n指定自动清理在任意给定数据库上运行的最小延迟。在每一轮中后台进程检查数据库并根据需要为数据库中的表发出ANALYZE命令。 如果指定值时没有单位，则以秒为单位。默认值为1分钟（1min）。该参数只能在postgresql.conf文件或在服务器命令行上设置。\n  autoanalyze_base_threshold (integer)\n指定能在一个表上触发ANALYZE的被插入、被更新或被删除元组的最小数量。默认值为50个元组。该参数只能在postgresql.conf文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。\n  autoanalyze_scale_factor (floating point)\n指定一个表尺寸的分数，在决定是否触发ANALYZE时将它加到autoanalyze_base_threshold上。默认值为0.1（表尺寸的10%）。该参数只能在postgresql.conf文件或在服务器命令中设置。但是对个别表可以通过修改表存储参数来覆盖该设置。\n  "},{"id":9,"href":"/zh-cn/advanced/","title":"高级特性","parent":"欢迎访问红石数据库文档","content":""},{"id":10,"href":"/zh-cn/advanced/textsearch/","title":"中文搜索","parent":"高级特性","content":"全文搜索（或者文本搜索）提供了确定满足一个查询的自然语言文档的能力，并可以选择将它们按照与查询的相关度排序。最常用的搜索类型是找到所有包含给定查询词的文档并按照它们与查询的相似性顺序返回它们。查询和相似性的概念非常灵活并且依赖于特定的应用。最简单的搜索认为查询是一组词而相似性是查询词在文档中的频度。\n解析器     文本搜索解析器负责把未处理的文档文本划分成记号并且标识每一个记号的类型，而可能的类型集合由解析器本身定义。注意一个解析器完全不会修改文本 — 它简单地标识看似有理的词边界。因为这种有限的视野，对于应用相关的自定义解析器的需求就没有自定义字典那么强烈。目前Redrock Postgres只提供了两种内置解析器，它们已经被证实对很多种应用都适用。\n内置的中文解析器被称为pg_catalog.cjkparser。\n配置     全文搜索功能包括做更多事情的能力：跳过索引特定词（停用词）、处理同义词并使用更高级的解析，例如基于空白之外的解析。这个功能由文本搜索配置控制。PostgreSQL中有多种语言的预定义配置，并且你可以很容易地创建你自己的配置（psql的\\dF命令显示所有可用的配置）。\n内置的中文搜索配置被称为 pg_catalog.chinese。\n测试和调试文本搜索     一个自定义文本搜索配置的行为很容易变得混乱。本节中描述的函数对于测试文本搜索对象有用。你可以测试一个完整的配置，或者独立测试解析器和词典。\n配置测试     函数ts_debug允许简单地测试一个文本搜索配置。\nSELECT * FROM ts_debug(\u0026#39;chinese\u0026#39;, \u0026#39;关系数据库是一种用于存储相互关联的数据记录并提供数据访问的数据库。\u0026#39;);\ralias | description | token | dictionaries | dictionary | lexemes\r------------+--------------+--------+--------------+------------+----------\rcjk_words | CJK words | 关系 | {chinese} | chinese | {关系}\rcjk_words | CJK words | 数据库 | {chinese} | chinese | {数据库}\rcjk_words | CJK words | 是 | {chinese} | chinese | {是}\rcjk_words | CJK words | 一种 | {chinese} | chinese | {一种}\rcjk_words | CJK words | 用于 | {chinese} | chinese | {用于}\rcjk_words | CJK words | 存储 | {chinese} | chinese | {存储}\rcjk_words | CJK words | 相互 | {chinese} | chinese | {相互}\rcjk_words | CJK words | 关联 | {chinese} | chinese | {关联}\rcjk_words | CJK words | 的 | {chinese} | chinese | {的}\rcjk_words | CJK words | 数据 | {chinese} | chinese | {数据}\rcjk_words | CJK words | 记录 | {chinese} | chinese | {记录}\rcjk_words | CJK words | 并 | {chinese} | chinese | {并}\rcjk_words | CJK words | 提供 | {chinese} | chinese | {提供}\rcjk_words | CJK words | 数据 | {chinese} | chinese | {数据}\rcjk_words | CJK words | 访问 | {chinese} | chinese | {访问}\rcjk_words | CJK words | 的 | {chinese} | chinese | {的}\rcjk_words | CJK words | 数据库 | {chinese} | chinese | {数据库}\rpunc_words | punctuations | 。 | {chinese} | chinese | {。} 解析器测试     函数ts_parse 允许直接测试一个文本搜索解析器。\nSELECT * FROM ts_parse(\u0026#39;cjkparser\u0026#39;, \u0026#39;关系数据库是一种用于存储相互关联的数据记录并提供数据访问的数据库。\u0026#39;);\rtokid | token\r-------+--------\r1 | 关系\r1 | 数据库\r1 | 是\r1 | 一种\r1 | 用于\r1 | 存储\r1 | 相互\r1 | 关联\r1 | 的\r1 | 数据\r1 | 记录\r1 | 并\r1 | 提供\r1 | 数据\r1 | 访问\r1 | 的\r1 | 数据库\r18 | 。 "},{"id":11,"href":"/zh-cn/advanced/plscheme/","title":"PL/Scheme","parent":"高级特性","content":"PL/Scheme 是一个用于 Scheme 编程语言的 PostgreSQL 过程语言处理程序。 PL/scheme 在后台使用 Chibi Scheme 作为其 Scheme 解释器。 凭借大量内置的 SRFI 和 Chibi Scheme 的完全 R7RS 兼容性，PL/scheme 可以以 Lisp 风格启动 PostgreSQL 过程。\nPL/Scheme 函数和参数     要用 PL/Scheme 语言创建一个函数，可使用标准的 CREATE FUNCTION语法：\nCREATE FUNCTION funcname (argument-types) RETURNS return-type AS $$ # PL/Scheme 函数体 $$ LANGUAGE plscheme; 函数的主体就是普通的 Scheme 代码。事实上，PL/Scheme 的粘合代码会把它 包裹在一个 Scheme 子程序中。一个 PL/Scheme 函数会在一种标量上下文中 被调用，因此它无法返回列表。如下文所述，可以通过返回引用来返回 非标量值（数组、记录和集合）。\n在一个 PL/Scheme 过程中，任何从Scheme代码返回的值都会被忽略。\nPL/Scheme 也支持用DO语句调用的匿名代码块：\nDO $$ # PL/Scheme 代码 $$ LANGUAGE plscheme; 一个匿名代码块没有参数，并且它返回的任何值都会被抛弃。否则其行为就像一个函数。\nCREATE FUNCTION命令的语法要求函数 体被写作一个字符串常量。通常对字符串常量使用美元引用（见 第 4.1.2.4 节）最方便。如果选择使用 转义字符串语法E''，必须双写任何在函数体中使用的单引号 （'）和反斜线（\\）（见 第 4.1.2.1 节）。\n参数和结果的处理和在任何其他 Scheme 子程序中一样：参数会以 Scheme 变量的形式传递到函数体中，并且函数中计算的最后一个表达式会作为结果值返回。\n例如，一个返回两个整数值中较大值的函数可以定义为：\nCREATE FUNCTION scheme_max (a integer, b integer) RETURNS integer AS $$ (if (\u0026gt; a b) a b) $$ LANGUAGE plscheme; "},{"id":12,"href":"/zh-cn/features/undo/","title":"回滚段","parent":"基础特性","content":"   回滚段和事务 事务回滚 管理回滚段      Redrock Postgres 维护事务操作的记录，统称为撤消数据。 Redrock Postgres 使用 undo 来执行以下操作：\n 回滚活跃事务 恢复异常结束的事务 提供读一致性  Redrock Postgres 将 undo 数据存储在数据库中而不是外部日志中。 undo 数据存储在与数据块一样更新的块中，对这些块的更改会产生重做。 通过这种方式，Redrock Postgres 可以高效地访问 undo 数据，而无需读取外部日志。\nundo 数据存储在独立的表空间中。 Redrock Postgres 提供了一种完全自动化的机制，称为自动回滚段管理模式，用于管理回滚段和存储空间。\n回滚段和事务     当事务开始时，数据库将事务绑定（分配）到回滚段，因此绑定到事务表。\n多个活动事务可以同时写入相同的回滚段或不同的回滚段。 例如，事务 T1 和 T2 都可以写入 undo U1，或者 T1 可以写入 U1 而 T2 写入 undo U2。\n事务回滚     当执行 ROLLBACK语句时，数据库使用 undo 记录回滚未提交事务对数据库所做的更改。 在恢复期间，数据库回滚从联机重做日志应用到数据文件的任何未提交的更改。 undo 记录通过在另一个用户正在更改数据的同时为访问数据的用户维护数据的前映像来提供读取一致性。\n管理回滚段     初始化数据库集群数据目录后，数据库中默认会产生4个集群级回滚段和8个数据库级别的回滚段。用户可以使用以下语句查看当前数据库中的回滚段信息：\nSELECT c.relname, c.relisshared, u.undoid, u.undrelid, pg_size_pretty(pg_relation_size(c.oid)) as undsize FROM pg_undo u LEFT JOIN pg_class c ON u.undrelid = c.oid; "},{"id":13,"href":"/zh-cn/features/recyclebin/","title":"回收站","parent":"基础特性","content":"   什么是回收站？  回收站中的对象命名   查看和查询回收站中的对象 清除回收站中的对象 从回收站恢复表      在删除一个表时，数据库不会立即删除与该表关联的物理文件和回收占用空间。数据库会重命名表，并将其和任何关联对象放置到回收站中，如果表被错误删除，则可以在以后进行恢复。\n什么是回收站？     回收站实际上是一个数据字典表，包含有关丢弃对象的信息。删除的表和任何关联对象（如索引、约束、类型等），它们的物理文件会保留一段时间，并且仍占用空间。\n它们会继续被计入用户空间配额，直到指定从回收站中清除，或者由于表空间需要被删除时，数据库必须清空回收站。\n每个用户都可以被认为有自己的回收站，因为除非用户具有 SUPERUSER 权限，否则用户在回收站中唯一有权访问的对象是用户拥有的对象。用户可以使用以下语句在回收站中查看其模式中的对象：\nSELECT * FROM pg_catalog.pg_recyclebin WHERE namespace = to_regnamespace(CURRENT_SCHEMA)::oid; DDL 命令删除的对象将会被移动到回收站。在移动到回收站的已删除对象中包括以下类型的对象：\n 表 回滚段 索引 约束 类型 函数  当您删除表空间时，表空间中的对象不会放置在回收站中，数据库会清除回收站中位于表空间中的任何对象。同样：\n 删除用户时，属于该用户的任何对象都不会放置在回收站中，并且回收站中的任何对象都会清除。 删除模式时，属于该模式的任何对象都不会放置在回收站中，并且回收站中的任何对象都会清除。  回收站中的对象命名     当删除的表移动到回收站时，该表及其关联的对象将被指定为系统生成的名称。这是必要的，以避免如果多个表具有相同的名称，可能会出现名称冲突。在以下情况下可能发生这种情况：\n 用户删除表，用相同的名称重新创建表，然后再次删除表。 两个用户有同名的表，两个用户都删除他们的表。  删除对象重命名约定如下：\npg_dropped_[object_type]_[object_id] 其中：\n object_type 是对象类型名称，例如：table, index, constraint, type, function。 object_id 是该对象的唯一标识符，这使得回收站名称在当前数据库中唯一。  查看和查询回收站中的对象     您可以查询系统目录pg_recyclebin以识别数据库分配给已删除对象的名称，如以下示例所示：\nSELECT objname, oldname FROM pg_catalog.pg_recyclebin WHERE namespace = to_regnamespace(\u0026#39;hr\u0026#39;)::oid; objname | oldname -----------------------+----------- pg_dropped_table_18762 | employees 您还可以使用GUI管理工具（如DBeaver、pgAdmin 4）查看回收站的内容，在指定数据库下展开系统模式pg_recyclebin以查看所有已删除的对象。\n您可以查询回收站中的对象，就像查询其他对象一样。但是，您必须用它在回收站中的标识指定对象的名称。例如：\nSELECT * FROM pg_recyclebin.pg_dropped_table_18762; 清除回收站中的对象     如果您决定永远不会从回收站恢复一个删除对象，则可以使用VACUUM语句从回收站中彻底删除指定对象及其关联对象，并释放其存储空间。您需要与删除对象时相同的权限。\n使用VACUUM语句清除表时，可以使用回收站中已知表的名称或表的原始名称。回收站名称可以从系统目录pg_recyclebin中获取，如“查看和查询回收站中的对象”所示。以下假设示例清除表hr.employees，该表在放入回收站时被重命名为pg_recyclebin.pg_dropped_table_18762：\nVACUUM pg_recyclebin.pg_dropped_table_18762; 您可以使用以下语句获得相同的结果：\nVACUUM hr.employees; 如果您具有 SUPERUSER 权限或您是当前数据库所有者，则可以使用以下语句清除整个回收站，并释放对象占用的空间：\nVACUUM; 您还可以使用VACUUM语句从回收站中清除索引或回滚段。\n从回收站恢复表     使用 CREATE TABLE \u0026hellip; LIKE 语句可以恢复在回收站中的已删除对象。\n您应该指定回收站中已删除表的名称。回收站名称可以从系统目录pg_recyclebin中获取，如“查看和查询回收站中的对象”所示。要使用 CREATE TABLE \u0026hellip; LIKE 语句，您需要访问已删除表所需的SELECT权限。\n以下示例恢复 employees 表，并为其分配新名称：\nCREATE TABLE hr.employees2 (LIKE pg_recyclebin.pg_dropped_table_18762 INCLUDING ALL); INSERT INTO hr.employees2 SELECT * FROM pg_recyclebin.pg_dropped_table_18762; 如果您多次删除表，回收站中系统生成的对象名称非常有用。例如，假设您在回收站中有三个版本的 employees 表，并且您希望恢复第二个版本。您可以查询回收站，然后恢复到系统生成的相应对象名称，如以下示例所示。在查询中包括删除时间可以帮助您验证您正在恢复正确的表。\nSELECT objname, oldname, droptime FROM pg_catalog.pg_recyclebin; objname | oldname | droptime -----------------------+-----------+-------------------- pg_dropped_table_18762 | employees | 2006-02-05:21:05:52 pg_dropped_table_18924 | employees | 2006-02-05:21:25:13 pg_dropped_table_19510 | employees | 2006-02-05:22:05:53 CREATE TABLE hr.employees2 (LIKE pg_recyclebin.pg_dropped_table_18924 INCLUDING ALL); INSERT INTO hr.employees2 SELECT * FROM pg_recyclebin.pg_dropped_table_18924; "},{"id":14,"href":"/zh-cn/features/statement-atomicity/","title":"语句级原子性","parent":"基础特性","content":"示例事务：帐户借贷     为了说明事务的概念，考虑一个银行数据库。当一个客户将钱从储蓄账户转移到支票帐户时，事务必须由三个单独的操作组成：\n  减少储蓄账户余额\n  增加支票账户余额\n  在事务日志中记录这笔交易\n  Redrock Postgres 必须考虑两种情况。如果所有三个 SQL 语句都对该账号维持了正确的余额，则事务的效果可以应用到数据库中。但是，如果某个问题，如资金不足、帐号无效、或硬件故障，阻止了事务中某些语句的完成，则数据库必须回滚整个事务，以便所有帐户的余额是正确的。\n图 1 说明了银行事务。第一条语句从储蓄帐户3209中减去 500 美元。第二条语句向支票帐户3208增加500 美元。第三条语句在日志表中插入这笔转账记录。最后一个语句提交事务。\n    图 1 银行事务    语句级原子性     Redrock Postgres 支持语句级原子性，这意味着 SQL 语句是一个原子工作单元，要么完全成功，要么完全失败。\n成功的语句不同于已提交事务。如果一个SQL 语句能被数据库正确分析，并作为一个原子单位来运行且未产生错误，且所有行都被正确更改，则这个SQL 语句是成功执行的。\n如果 SQL 语句在执行过程中导致错误，则它是不成功的，该语句中的所有影响都将被回滚。此操作是一个语句级回滚。此操作具有以下特征：\n  未成功的 SQL 语句只会导致它本身执行的工作丢失。\n未成功的语句不会导致丢失当前事务中该语句之前的任何工作。例如，若图1中第二个UPDATE语句的执行导致错误并被回滚，但由第一个UPDATE语句执行的工作是不会被回滚的。第一个UPDATE语句可以由用户显式提交或回滚。\n  回滚的效果是，好像该语句从来未运行过。\n原子语句的副作用被视为原子语句的一部分，例如，由语句执行所引发的触发器调用。作为原子语句的一部分所产生的所有工作，要么都成功，要么都失败。\n  由错误导致语句级回滚的一个示例，是尝试插入重复的主键。死锁中的某个为争用相同数据的SQL 语句，也会导致语句级回滚。然而，在解析中发现的错误，比如语法错误，实际上尚未运行，因此不会导致语句级回滚。\n"},{"id":15,"href":"/zh-cn/commands/","title":"SQL 命令","parent":"欢迎访问红石数据库文档","content":"这部分包含 Redrock Postgres 支持的SQL命令的参考信息。每条命令的标准符合和兼容的信息可以在相关的参考页中找到。\n目录\n ALTER UNDO — 更改一个回滚段的定义 CREATE UNDO — 定义一个新回滚段 DROP UNDO — 删除一个回滚段 VACUUM — 清理一个数据库  "},{"id":16,"href":"/zh-cn/features/network-tablespace/","title":"网络表空间","parent":"基础特性","content":"   规划 部署计算服务器 部署存储服务器 创建基于网络的数据库 创建网络表空间      Redrock Postgres 支持基于网络的表空间。 基于该能力，Redrock Postgres 可以做到数据库的计算和存储的分离部署。\n规划     准备好计算服务器和存储服务器环境，推荐环境配置：\n 计算服务器应该采用较高的处理器和内存配置； 存储服务器应该采用IO处理能力偏高的存储配置，存储空间满足数据存储要求； 计算服务器和存储服务器之间，尽量采用高带宽和低延迟的网络；  如果需要在数据库服务器中创建多个网络表空间，对应地，就需要准备多台存储服务器。\n部署计算服务器     按照下述步骤，部署计算服务器：\n 参考 Redrock Postgres 安装指导，安装软件包。 如果数据库服务器正在运行，停止它。 使用任何趁手的文件系统备份工具（例如tar或者 cpio，不是pg_dump 或者pg_dumpall）执行备份。 启动服务器。  部署存储服务器     按照下述步骤，部署存储服务器：\n 参考 Redrock Postgres 安装指导，安装软件包。 如果数据库服务器正在运行，停止它。 移除所有位于集群数据目录下的文件和子目录。 从你的文件系统备份中恢复数据库文件。注意它们要使用正确的所有权恢复（数据库系统用户，不是root！）并且使用正确的权限。 设置postgresql.conf中的监听地址和端口，并且在集群数据目录中创建一个storage.signal文件。修改pg_hba.conf以允许来自计算服务器的连接。 启动服务器。  创建基于网络的数据库     登录计算服务器，使用数据库超级用户连接到数据库服务中的 postgres 数据库，创建基于网络的数据库。配置的一个简单例子是：\nCREATE DATABASE netdb STORAGE remote LOCATION\r\u0026#39;host=192.168.1.50 port=5432 user=postgres password=pgpass\u0026#39;;   在 Redrock Postgres 中，创建一个数据库时会在这个数据库中附带创建一个默认表空间，上例中新建的数据库会产生一个默认的网络表空间。  创建网络表空间     使用数据库超级用户连接到数据库服务中的新建数据库 netdb，创建基于网络的表空间。下面是配置的一个简单例子，使用额外的两台存储服务器创建了两个网络表空间：\nCREATE TABLESPACE netts1 STORAGE remote LOCATION\r\u0026#39;host=192.168.1.51 port=5432 user=postgres password=pgpass\u0026#39;;\rCREATE TABLESPACE netts2 STORAGE remote LOCATION\r\u0026#39;host=192.168.1.52 port=5432 user=postgres password=pgpass\u0026#39;; 然后就可以使用这些网络表空间创建表和索引了。\n"},{"id":17,"href":"/zh-cn/advanced/monitor-stats/","title":"运行统计视图","parent":"高级特性","content":"   统计收集配置 查看统计信息 pg_stat_activity pg_stat_wait_event pg_stat_replication pg_stat_database pg_stat_all_tables pg_stat_all_undos pg_stat_all_indexes pg_statio_all_tables pg_statio_all_undos pg_statio_all_indexes pg_statio_all_sequences      Redrock Postgres的统计收集器是一个支持收集和报告服务器活动信息的子系统。 目前，这个收集器可以对表和索引的访问计数，计数可以按磁盘块和个体行来进行。它还跟踪每个表中的总行数、每个表的分析动作的信息。它也统计调用用户定义函数的次数以及在每次调用中花费的总时间。\nRedrock Postgres也支持报告有关系统正在干什么的动态信息，例如当前正在被其他服务器进程执行的命令以及系统中存在哪些其他连接。这个功能是独立于收集器进程存在的。\n统计收集配置     因为统计收集给查询执行增加了一些负荷，系统可以被配置为收集或不收集信息。这由配置参数控制，它们通常在postgresql.conf中设置（关于设置配置参数的细节请见第 19 章）。\n参数track_activities允许监控当前被任意服务器进程执行的命令。\n参数track_counts控制是否收集关于表和索引访问的统计信息。\n参数track_functions启用对用户定义函数使用的跟踪。\n参数track_io_timing启用对块读写次数的监控。\n参数track_wait_events控制是否收集关于等待事件的统计信息。\n通常这些参数被设置在postgresql.conf中，这样它们会应用于所有服务器进程，但是可以在单个会话中使用SET命令打开或关闭它们（为了阻止普通用户对管理员隐藏他们的活动，只有超级用户被允许使用SET来改变这些参数）。\n统计收集器通过临时文件将收集到的信息传送给其他PostgreSQL进程。这些文件被存储在名字由stats_temp_directory参数指定的目录中，默认是pg_tmp/stats。为了得到更好的性能，stats_temp_directory可以被指向一个基于 RAM 的文件系统来降低物理 I/O 需求。当服务器被干净地关闭时，一份统计数据的永久拷贝被存储在pg_stat子目录中，这样在服务器重启后统计信息能被保持。当在服务器启动时执行恢复时（例如立即关闭、服务器崩溃以及时间点恢复之后），所有统计计数器会被重置。\n查看统计信息     表 1中列出了一些预定义视图 可以用来显示系统的当前状态。 表 2中列出了另一些视图可以 显示统计收集的结果。你也可以使用底层统计函数（在 第 27.2.3 节中讨论）来建立自定义的视图。\n在使用统计信息监控收集到的数据时，你必须了解这些信息并非是实时更新的。每个独立的服务器进程只在进入闲置状态之前才向收集器传送新的统计计数；因此正在进行的查询或事务并不影响显示出来的总数。同样，收集器本身也最多每PGSTAT_STAT_INTERVAL毫秒（缺省为 500ms，除非在编译服务器的时候修改过）发送一 次新的报告。因此显示的信息总是落后于实际活动。但是由track_activities收集的当前查询信息总是最新的。\n另一个重点是当一个服务器进程被要求显示任何这些统计信息时，它首先取得收集器进程最近发出的报告并且接着为所有统计视图和函数使用这个快照，直到它的当前事务的结尾。因此只要你继续当前事务，统计数据将会一直显示静态信息。相似地，当任何关于所有会话的当前查询的信息在一个事务中第一次被请求时，这样的信息将被收集。并且在整个事务期间将显示相同的信息。这是一种特性而非缺陷，因为它允许你在该统计信息上执行多个查询并且关联结果而不用担心那些数字会在你不知情的情况下改变。但是如果你希望用每个查询都看到新结果，要确保在任何事务块之外做那些查询。或者，你可以调用pg_stat_clear_snapshot()，那将丢弃当前事务的统计快照（如果有）。下一次对统计性信息的使用将导致获取一个新的快照。\n一个事务也可以在视图pg_stat_xact_all_tables、pg_stat_xact_all_undos, pg_stat_xact_sys_tables、pg_stat_xact_user_tables和pg_stat_xact_user_functions中看到它自己的统计信息（还没有被传送给收集器）。这些数字并不像上面所述的那样行动，相反它们在事务期间持续被更新。\n表 1中显示的动态统计视图中的一些信息是有安全限制的。 普通用户只能看到关于他们自己的会话的所有信息（属于他们是成员的角色的会话）。 在关于其他会话的行中，许多列将为空。 但是，请注意，一个会话的存在和它的一般属性，例如会话用户和数据库，对所有用户都是可见的。超级用户和内置角色pg_read_all_stats的成员（参见第 21.5 节）可以看到所有会话的所有信息。\n表 1. 动态统计视图\n   视图名称 描述     pg_stat_activity 每个服务器进程一行，显示与那个进程的当前活动相关的信息，例如状态和当前查询。详见pg_stat_activity 。   pg_stat_wait_event 每个等待事件一行，显示有关每个发生的等待事件的等待信息的统计信息。有关详细信息，请参阅 pg_stat_wait_event。   pg_stat_replication 每一个 WAL 发送进程一行，显示有关到该发送进程连接的后备服务器的复制的统计信息。 详见pg_stat_replication.    表 2. 已收集统计信息的视图\n   视图名称 描述     pg_stat_database 每个数据库一行，显示数据库范围的统计信息。详见pg_stat_database。   pg_stat_all_tables 当前数据库中每个表一行，显示有关访问指定表的统计信息。详见pg_stat_all_tables。   pg_stat_sys_tables 和pg_stat_all_tables一样，但只显示系统表。   pg_stat_user_tables 和pg_stat_all_tables一样，但只显示用户表。   pg_stat_xact_all_tables 和pg_stat_all_tables相似，但计数动作只在当前事务内发生（还没有被包括在pg_stat_all_tables和相关视图中）。用于生存和死亡行数量的列以及分析动作在此视图中不出现。   pg_stat_xact_sys_tables 和pg_stat_xact_all_tables一样，但只显示系统表。   pg_stat_xact_user_tables 和pg_stat_xact_all_tables一样，但只显示用户表。   pg_stat_all_undos 当前数据库中每个回滚段一行，显示有关访问指定回滚段的统计信息。详见pg_stat_all_undos。   pg_stat_xact_all_undos 和pg_stat_all_undos相似，但计数动作只在当前事务内发生（还没有被包括在pg_stat_all_undos和相关视图中）。用于生存和死亡行数量的列在此视图中不出现。   pg_stat_all_indexes 当前数据库中的每个索引一行，显示：表OID、索引OID、模式名、表名、索引名、 使用了该索引的索引扫描总数、索引扫描返回的索引记录数、使用该索引的简 单索引扫描抓取的活表(livetable)中数据行数。 当前数据库中的每个索引一行，显示与访问指定索引有关的统计信息。详见pg_stat_all_indexes。   pg_stat_sys_indexes 和pg_stat_all_indexes一样，但只显示系统表上的索引。   pg_stat_user_indexes 和pg_stat_all_indexes一样，但只显示用户表上的索引。   pg_statio_all_tables 当前数据库中每个表一行(包括TOAST表)，显示：表OID、模式名、表名、 从该表中读取的磁盘块总数、缓冲区命中次数、该表上所有索引的磁盘块读取总数、 该表上所有索引的缓冲区命中总数、在该表的辅助TOAST表(如果存在)上的磁盘块读取总数、 在该表的辅助TOAST表(如果存在)上的缓冲区命中总数、TOAST表的索引的磁盘块读 取总数、TOAST表的索引的缓冲区命中总数。 当前数据库中的每个表一行，显示有关在指定表上 I/O 的统计信息。详见pg_statio_all_tables。   pg_statio_sys_tables 和pg_statio_all_tables一样，但只显示系统表。   pg_statio_user_tables 和pg_statio_all_tables一样，但只显示用户表。   pg_statio_all_undos 当前数据库中每个回滚段一行，显示：回滚段OID、模式名、 回滚段名、该回滚段的磁盘块读取总数、该回滚段的缓冲区命中总数。 当前数据库中的每个回滚段包含一行，该行显示指定回滚段上有关 I/O 的统计信息。详见pg_statio_all_undos。   pg_statio_all_indexes 当前数据库中每个索引一行，显示：表OID、索引OID、模式名、 表名、索引名、该索引的磁盘块读取总数、该索引的缓冲区命中总数。 当前数据库中的每个索引一行，显示与指定索引上的 I/O 有关的统计信息。详见pg_statio_all_indexes。   pg_statio_sys_indexes 和pg_statio_all_indexes一样，但只显示系统表上的索引。   pg_statio_user_indexes 和pg_statio_all_indexes一样，但只显示用户表上的索引。   pg_statio_all_sequences 当前数据库中每个序列对象一行，显示：序列OID、模式名、序列名、序列的磁盘读取总数、序列的缓冲区命中总数。 当前数据库中的每个序列一行，显示与指定序列上的 I/O 有关的统计信息。详见pg_statio_all_sequences。   pg_statio_sys_sequences 和pg_statio_all_sequences一样，但只显示系统序列（目前没有定义系统序列，因此这个视图总是为空）。   pg_statio_user_sequences 和pg_statio_all_sequences一样，但只显示用户序列。    针对每个索引的统计信息对于判断哪个索引正被使用以及它们的效果特别有用。\npg_statio_系列视图主要用于判断缓冲区的效果。当实际磁盘读取数远小于缓冲区命中时，这个缓冲能满足大部分读请求而无需进行内核调用。但是，这些统计信息并没有给出所有的事情：由于PostgreSQL处理磁盘 I/O 的方式，不在PostgreSQL缓冲区中的数据库仍然驻留在内核的 I/O 缓存中，并且因此可以被再次读取而不需要物理磁盘读取。我们建议希望了解PostgreSQL I/O 行为更多细节的用户将PostgreSQL统计收集器和操作系统中允许观察内核处理 I/O 的工具一起使用。\npg_stat_activity     pg_stat_activity视图将为每一个服务器进程有一行，显示与该进程的当前活动相关的信息。\n表 3. pg_stat_activity 视图\n   列 类型 描述     datid oid 这个后端连接到的数据库的OID   datname name 这个后端连接到的数据库的名称   pid integer 这个后端的数据库进程 ID   spid integer 这个后端的系统进程 ID   tid integer 这个后端的线程 ID   usesysid oid 登录到这个后端的用户的 OID   usename name 登录到这个后端的用户的名称   application_name text 连接到这个后端的应用的名称   client_addr inet 连接到这个后端的客户端的 IP 地址。如果这个域为空，它表示客户端通过服务器机器上的一个 Unix 套接字连接或者这是一个内部进程（如自动分析）。   client_hostname text 已连接的客户端的主机名，由client_addr的反向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有log_hostname被启用时才会非空。   client_port integer 客户端用以和这个后端通信的 TCP 端口号，如果使用 Unix 套接字则为-1   backend_start timestamp with time zone 这个进程被启动的时间。对客户端后端来说就是客户端连接到服务器的时间。   xact_start timestamp with time zone 这个进程的当前事务被启动的时间，如果没有活动事务则为空。如果当前查询是它的第一个事务，这一列等于query_start。   query_start timestamp with time zone 当前活动查询被开始的时间，如果state不是active，这个域为上一个查询被开始的时间   state_change timestamp with time zone state上一次被改变的时间   wait_event_type text 后端正在等待的事件类型，如果不存在则为 NULL。可能的值有：LWLock：后端正在等待一个轻量级锁。每一个这样的锁保护着共享内存中的一个特殊数据结构。wait_event将含有一个标识该轻量级锁目的的名称（一些锁具有特定的名称，其他是一组具有类似目的的锁中的一部分）。Lock：后端正在等待一个重量级锁。重量级锁，也称为锁管理器锁或者简单锁，主要保护 SQL 可见的对象，例如表。不过，它们也被用于确保特定内部操作的互斥，例如关系扩展。wait_event将标识等待的锁的类型。BufferPin：服务器进程正在等待访问一个数据缓冲区，而此时没有其他进程正在检查该缓冲区。如果另一个进程持有一个最终从要访问的缓冲区中读取数据的打开的游标，缓冲区 pin 等待可能会被拖延。Activity：服务器进程处于闲置状态。这被用于在其主处理循环中等待活动的系统进程。wait_event将标识特定的等待点。Extension：服务器进程正在一个扩展模块中等待活动。这一个分类被用于要跟踪自定义等待点的模块。Client：服务器进程正在一个套接字上等待来自用户应用的某种活动，并且该服务器预期某种与其内部处理无关的事情发生。wait_event将标识特定的等待点。IPC：服务器进程正在等待来自服务器中另一个进程的某种活动。wait_event将标识特定的等待点。Timeout：服务器进程正在等待一次超时发生。wait_event将标识特定的等待点。IO：服务器进程正在等待一次IO完成。wait_event将标识特定的等待点。   wait_event text 如果后端当前正在等待，则是等待事件的名称，否则为 NULL。详见表 27.4。   memory_used bigint 这个后端占用的内存大小，单位字节   state text 这个后端的当前总体状态。可能的值是：active：后端正在执行一个查询。idle：后端正在等待一个新的客户端命令。idle in transaction：后端在一个事务中，但是当前没有正在执行一个查询。idle in transaction (aborted)：这个状态与idle in transaction相似，不过在该事务中的一个语句导致了一个错误。fastpath function call：后端正在执行一个 fast-path 函数。disabled：如果在这个后端中track_activities被禁用，则报告这个状态。   backend_xid xid 这个后端的顶层事务标识符（如果存在）。   backend_mintime logicaltime 当前后端的mintime范围。   query text 这个后端最近查询的文本。如果state为active，这个域显示当前正在执行的查询。在所有其他状态下，它显示上一个被执行的查询。默认情况下，查询文本会被截断至1024个字符，这个值可以通过参数track_activity_query_size更改。   backend_type text 当前后端的类型。可能的类型是 autoanalyze launcher, autoanalyze worker, logical replication launcher, logical replication worker, parallel worker, background writer, client backend, checkpointer, startup, walreceiver, walsender 以及 walwriter。 除此以外，由扩展注册的后台Worker可能有额外的类型。     wait_event和state列是独立的。如果一个后端处于active状态，它可能是也可能不是某个事件上的waiting。如果状态是active并且wait_event为非空，它意味着一个查询正在被执行，但是它被阻塞在系统中某处。  表 4. 等待事件类型\n   等待事件类型 描述     Activity 服务器进程空闲。此事件类型表示在其主处理循环中等待活动的进程。 wait_event将识别特定的等待点;参见表 5。   BufferPin 服务器进程正在等待对数据缓冲的独占访问。 如果另一个进程持有一个打开的游标，该游标最后一次从相关缓冲区读取数据，则缓冲区销等待可能是漫长的。参见表 6。   Client 服务器进程正在等待连接到用户应用程序的套接字上的活动。 因此，服务器预计发生一些独立于其内部进程的事情。wait_event将识别特定的等待点；参见表 7。   Extension 服务器进程正在等待扩展模块定义的某个条件。参见表 8。   IO 服务器进程正在等待一个I/O操作完成。wait_event将识别特定的等待点；参见表 9。   IPC 服务器进程正在等待与另一个服务器进程进行交互。wait_event将识别特定的等待点;参见表 10。   Lock 服务器进程正在等待一个重量级锁。重量级锁，也称为锁管理器锁或简单锁，主要保护表等SQL可见对象。 然而，它们也用于确保某些内部操作的互斥，例如关系扩展。wait_event将识别等待的锁的类型；参见表 11。   LWLock 服务器进程正在等待一个轻量级锁。大多数这样的锁保护共享内存中的特定数据结构。 wait_event将包含标识轻量级锁用途的名称。 (有些锁有特定的名称；其他锁是一组锁的一部分，每个锁具有类似的目的。)参见表 12。   Timeout 服务器进程正在等待超时过期。wait_event将识别特定的等待点；参见表 13。    表 5. Activity类型的等待事件\n   Activity 等待事件 描述     ArchiverMain 在归档进程的主循环中等待。   AnalyzeLauncherMain 在自动清理启动过程的主循环中等待。   BgWriterHibernate 在后台写进程中等待，休眠状态。   BgWriterMain 在后台写进程主循环中等待。   CheckpointerMain 在校验指针进程的主循环中等待。   LogicalApplyMain 在逻辑复制应用进程的主循环中等待。   LogicalLauncherMain 在逻辑复制启动器进程的主循环中等待。   PgStatMain 在统计收集器进程的主循环中等待。   RecoveryWalStream 流恢复期间，在启动进程主循环等待WAL到达。   SysLoggerMain 在syslogger进程的主循环中等待。   WalReceiverMain 在WAL接收器进程的主循环中等待。   WalSenderMain 在WAL发送者进程的主循环中等待。   WalWriterMain 在WAL写入进程的主循环中等待。    表 6. BufferPin类型的等待事件\n   BufferPin 等待事件 描述     BufferPin 等待获得缓冲区上的独占销。    表 7. Client类型的等待事件\n   Client 等待事件 描述     ClientRead 等待从客户端读取数据。   ClientWrite 等待写入数据到客户端。   GSSOpenServer 在建立GSSAPI会话时等待从客户端读取数据。   LibPQWalReceiverConnect 在WAL接收器等待与远程服务器建立连接。   LibPQWalReceiverReceive 在WAL接收器中等待从远程服务器接收数据。   LibPQStorageConnect 在计算服务器等待与远程存储服务器建立连接。   LibPQStorageReceive 在计算服务器等待从远程存储服务器接收数据。   SSLOpenServer 在尝试连接时等待SSL。   WalReceiverWaitStart 等待启动进程发送用于流复制的初始数据。   WalSenderWaitForWAL 在WAL发送器进程中等待WAL被刷新。   WalSenderWriteData 在WAL发送器进程中处理WAL接收器的回复时，等待任何活动。    表 8. Extension类型的等待事件\n   Extension 等待事件 描述     Extension 在扩展中等待。    表 9. IO类型的等待事件\n   IO 等待事件 描述     BufFileRead 等待从缓冲文件中读取。   BufFileWrite 等待对缓冲文件的写入。   ControlFileRead 等待读取pg_control文件。   ControlFileSync 等待pg_control文件到达持久存储。   ControlFileSyncUpdate 等待更新pg_control文件以达到持久存储。   ControlFileWrite 等待写入pg_control文件。   ControlFileWriteUpdate 等待写入更新pg_control文件。   CopyFileRead 在文件复制操作期间等待读取。   CopyFileWrite 在文件拷贝操作期间等待写入。   DSMFillZeroWrite 等待用零填充动态共享内存备份(backing)文件。   DataFileExtend 等待关系数据文件被扩展。   DataFileFlush 等待关系数据文件达到持久存储。   DataFileImmediateSync 等待关系数据文件到持久存储的立即同步。   DataFilePrefetch 等待关系数据文件的异步预取。   DataFileRead 等待对关系数据文件的读取。   DataFileSync 等待对关系数据文件的更改达到持久存储。   DataFileTruncate 等待关系数据文件被截断。   DataFileWrite 等待对关系数据文件的写入。   LockFileAddToDataDirRead 在向数据目录锁文件中添加一行时等待读取。   LockFileAddToDataDirSync 等待数据到达持久存储，同时向数据目录锁文件添加一行。   LockFileAddToDataDirWrite 在向数据目录锁文件中添加一行时等待写操作。   LockFileCreateRead 创建数据目录锁文件时等待读取。   LockFileCreateSync 在创建数据目录锁文件时等待数据到达持久存储。   LockFileCreateWrite 在创建数据目录锁文件时等待写操作。   LockFileReCheckDataDirRead 在重新检查数据目录锁文件期间等待读取。   LogicalRewriteCheckpointSync 等待逻辑重写映射到在检查点到达持久存储。   LogicalRewriteMappingSync 在逻辑重写期间等待映射数据到达持久存储   LogicalRewriteMappingWrite 在逻辑重写期间等待映射数据的写入。   LogicalRewriteSync 等待逻辑重写映射到达持久存储。   LogicalRewriteTruncate 等待在逻辑重写期间截断映射数据。   LogicalRewriteWrite 等待逻辑重写映射的写入。   RelationMapRead 等待关系映射文件的读取。   RelationMapSync 等待关系映射文件到达持久存储。   RelationMapWrite 等待对关系映射文件的写入。   ReorderBufferRead 在重新排序缓冲区管理期间等待读取。   ReorderBufferWrite 在重新排序缓冲区管理期间等待写操作。   ReorderLogicalMappingRead 在重新排序缓冲区管理期间等待读取逻辑映射。   ReplicationSlotRead 等待从复制槽位控制文件读取。   ReplicationSlotRestoreSync 等待复制槽控制文件到达持久存储，同时将其恢复到内存中。   ReplicationSlotSync 等待复制槽控制文件到达持久存储。   ReplicationSlotWrite 等待对复制槽控制文件的写入。   SLRUFlushSync 在检查点或数据库关闭期间等待SLRU数据到达持久存储。   SLRURead 等待读取SLRU页面。   SLRUSync 在写页面后等待SLRU数据到达持久存储。   SLRUWrite 等待SLRU页面的写入。   SnapbuildRead 等待读取序列化的历史目录快照。   SnapbuildSync 等待序列化历史目录快照到达持久存储。   SnapbuildWrite 等待串行历史目录快照的写入。   TimelineHistoryFileSync 等待通过流复制接收的时间线历史文件到达持久存储。   TimelineHistoryFileWrite 等待通过流复制接收的时间线历史文件的写入。   TimelineHistoryRead 等待读取时间线历史文件。   TimelineHistorySync 等待新创建的时间线历史文件到达持久存储。   TimelineHistoryWrite 等待写入新创建的时间线历史文件。   WALBootstrapSync 在引导过程中等待WAL达到持久存储。   WALBootstrapWrite 在引导过程中等待WAL页面的写入。   WALCopyRead 通过复制一个已有WAL段来创建一个新的WAL段时等待读取。   WALCopySync 等待通过复制一个已有WAL段到持久存储来创建一个新的WAL段。   WALCopyWrite 通过复制一个已有WAL段来创建一个新的WAL段时等待写入。   WALInitSync 等待一个新初始化的WAL文件到持久存储。   WALInitWrite 在初始化一个新的WAL文件时等待写入。   WALRead 等待WAL文件的读取。   WALSenderTimelineHistoryRead 在walsender时间线命令期间等待从时间线历史文件读取。   WALSync 等待WAL文件到达持久存储。   WALSyncMethodAssign 等待数据到达持久存储，同时分配一个新的WAL同步方法。   WALWrite 等待写入WAL文件。    表 10. IPC类型的等待事件\n   IPC 等待事件 描述     BackupWaitWalArchive 等待备份所需的WAL文件成功存档。   BgWorkerShutdown 等待后台工作者关闭。   BgWorkerStartup 等待后台工作者启动。   BtreePage 正等待继续并行B-树扫描所需的页号变得可用。   CheckpointDone 等待检查点完成。   CheckpointStart 等待检查点开始。   ExecuteGather 在执行Gather 计划节点时，等待子进程的活动。   LogicalSyncData 等待逻辑复制远程服务器发送用于初始表同步的数据。   LogicalSyncStateChange 等待逻辑复制远程服务器更改状态。   MessageQueueInternal 等待另一个进程附加到共享消息队列。   MessageQueuePutMessage 等待将协议消息写入共享消息队列。   MessageQueueReceive 等待从共享消息队列接收字节。   MessageQueueSend 等待将字节发送到共享消息队列。   ParallelBitmapScan 等待并行位图扫描被初始化。   ParallelCreateIndexScan 等待并行CREATE INDEX 工作者完成堆扫描。   ParallelFinish 等待并行工作人员完成计算。   ProcArrayGroupUpdate 等待组领导在并行操作结束时清除事务ID。   ProcSignalBarrier 等待屏障事件被所有后端处理。   Promote 等待备用系统提升。   RecoveryPause 等待恢复继续进行。   ReplicationOriginDrop 等待复制源变为非活动状态，以便可以删除它。   ReplicationSlotDrop 等待复制槽变为非活动状态，以便可以删除它。   SafeSnapshot 等待获取READ ONLY DEFERRABLE事务的有效快照。   SyncRep 在同步复制期间等待远程服务器的确认。   WalReceiverExit 等待 WAL 接收器退出。   WalReceiverWaitStart 等待启动过程发送用于流式复制的初始数据。   XactGroupUpdate 等待分组组长在并行操作结束时更新事务状态。    表 11. Lock类型的等待事件\n   Lock 等待事件 描述     advisory 等待获得一个建议用户锁。   extend 等待扩展一个关系。   object 等待获取非关系数据库对象上的锁。   page 等待获取一个关系页面上的锁。   relation 等待获得一个关系的锁。   transactionid 等待事务完成。   tuple 等待获取元组上的锁。   userlock 等待获取用户锁。   virtualxid 等待获取虚拟事务ID锁。    表 12. LWLock类型的等待事件\n   LWLock 等待事件 描述     AddinShmemInit 等待管理共享内存中的扩展空间分配。   AutoFile 等待更新pgsql.auto.conf文件。   Autoanalyze 等待读取或更新自动分析工作者的当前状态。   AutoanalyzeSchedule 等待确保选择为自动分析的表仍然需要清理。   BackgroundWorker 等待读取或更新后台工作者状态。   BufferContent 等待访问内存中的数据页。   BufferIO 等待数据页上的I/O。   BufferMapping 等待将数据块与缓冲池中的缓冲区关联。   Checkpoint 等待开始一个检查点。   CheckpointerComm 等待管理fsync请求。   ControlFile 等待读取或更新pg_control文件或创建一个新的WAL文件。   DatabaseState 等待更新数据库的状态。   DynamicSharedMemoryControl 等待读取或更新动态共享内存分配信息。   LockFastPath 等待读取或更新进程的快速路径锁信息。   LockManager 等待读取或更新关于“heavyweight”锁。   LogicalRepWorker 等待读取或更新逻辑复制工作器的状态。   NotifyBuffer 在NOTIFY 消息 SLRU缓冲区上等待I/O。   NotifyQueue 等待读取或更新NOTIFY 消息。   NotifyQueueTail 等待NOTIFY消息存储上的更新限制。   NotifySLRU 等待访问NOTIFY消息SLRU缓存。   OidGen 等待分配一个新的OID。   OldSnapshotTimeMap 等待读取或更新旧的快照控制信息。   PLogSpace 等待更新网络表空间的状态。   PLogWrite 等待 PLOG 缓冲区写入磁盘。   PredicateLockManager 等待访问可序列化事务使用的谓词锁信息。   ProcArray 等待访问每个进程共享的数据结构(通常情况，是获取快照或报告会话的事务ID)。   RelCacheInit 等待读取或更新pg_internal.init关系缓存初始化文件。   ReplicationOrigin 等待创建、删除或使用复制源。   ReplicationOriginState 等待读取或更新一个复制源的进度。   ReplicationSlotAllocation 等待分配或释放复制槽。   ReplicationSlotControl 等待读取或更新复制槽状态。   ReplicationSlotIO 在复制槽位上等待I/O。   SerializableFinishedList 等待访问已完成的可序列化事务列表。   SerializablePredicateList 等待访问可序列化事务持有的谓词锁列表。   SerializableXactHash 等待读取或更新关于可序列化事务的信息。   ShmemIndex 等待在共享内存中找到或分配空间。   SInvalRead 等待从共享目录失效队列中检索消息。   SInvalWrite 等待向共享编目失效队列添加消息。   SyncRep 等待读取或更新有关同步复制状态的信息。   SyncScan 等待选择同步表扫描的起始位置。   TablespaceMap 等待创建或删除表空间。   TwoPhaseState 等待读取或更新已准备事务的状态。   WALBufMapping 等待在WAL缓冲区中替换一个页面。   WALInsert 等待将WAL数据插入内存缓冲区。   WALWrite 等待WAL缓冲区写入磁盘。     扩展可以将LWLock类型添加到表 12所示的列表中。 在某些情况下，扩展名分配的名称不能在所有服务器进程中使用;因此LWLock等待事件可能只被报告为“extension”，而不是扩展名分配的名称。  表 13. Timeout类型的等待事件\n   Timeout 等待事件 描述     BaseBackupThrottle 当有限流活动时在基础备份期间等待。   PgSleep 由于调用pg_sleep或同类函数而等待。   RecoveryApplyDelay 由于延迟设置，在恢复期间等待应用WAL。   RecoveryRetrieveRetryInterval 当WAL数据无法从任何来源(pg_wal，存档或流)获得时，在恢复期间等待。    下面的例子展示了如何查看等待事件：\nSELECT pid, wait_event_type, wait_event FROM pg_stat_activity WHERE wait_event is NOT NULL;\rpid | wait_event_type | wait_event ------+-----------------+------------\r2540 | Lock | relation\r6644 | LWLock | ProcArray\r(2 rows) pg_stat_wait_event     pg_stat_wait_event视图将包含当前数据库中的每个等待事件的一行，显示有关每个已发生等待事件的等待信息的统计信息。\n表 14. pg_stat_wait_event 视图\n   列 类型 描述     wait_event_type text 后端正在等待的事件类型（如果有）; 否则为空。有关详细信息，请参阅 表 4。   wait_event text 如果后端当前正在等待，则等待事件名称，否则为 NULL。有关详细信息，请参阅 表 4 ~ 13。   waits bigint 此事件发生的次数   total_time double precision 在事件中花费的总时间（以毫秒为单位）   min_time double precision 在事件中花费的最短时间（以毫秒为单位）   max_time double precision 在事件中花费的最长时间（以毫秒为单位）   mean_time double precision 在事件中花费的平均时间（以毫秒为单位）    pg_stat_replication     pg_stat_replication视图中将为每一个 WAL 发送进程包含一行，用来显示与该发送进程连接的后备服务器的复制统计信息。这个视图中只会列出直接连接的后备机，下游后备服务器的信息不包含在此。\n表 15. pg_stat_replication 视图\n   列 类型 描述     pid integer 一个 WAL 发送进程的进程 ID   usesysid oid 登录到这个 WAL 发送进程的用户的 OID   usename name 登录到这个 WAL 发送进程的用户的名称   application_name text 连接到这个 WAL 发送进程的应用的名称   client_addr inet 连接到这个 WAL 发送进程的客户端的 IP 地址。 如果这个域为空，它表示该客户端通过服务器机器上的一个 Unix 套接字连接。   client_hostname text 连接上的客户端的主机名，由一次对client_addr 的逆向 DNS 查找报告。这个域将只对 IP 连接非空，并且只有在 log_hostname被启用时非空   client_port integer 客户端用来与这个 WAL 发送进程通讯的 TCP 端口号， 如果使用 Unix 套接字则为-1   backend_start timestamp with time zone 这个进程开始的时间，即客户端是何时连接到这个 WAL 发送进程的   backend_mintime logicaltime 由hot_standby_feedback报告 的这个后备机的mintime水平线。   state text 当前的 WAL 发送进程状态。 可能的值是：startup：这个WAL发送器正在启动。catchup：这个WAL发送器连接的后备机正在追赶主服务器。streaming：这个WAL发送器在它连接的后备服务器追上主服务器之后用流传送更改。backup：这个WAL发送器正在发送一个备份。stopping：这个WAL发送器正在停止。   sent_lsn pg_lsn 在这个连接上发送的最后一个预写式日志的位置   write_lsn pg_lsn 被这个后备服务器写入到磁盘的最后一个预写式日志的位置   flush_lsn pg_lsn 被这个后备服务器刷入到磁盘的最后一个预写式日志的位置   replay_lsn pg_lsn 被重放到这个后备服务器上的数据库中的最后一个预写式日志的位置   write_lag interval 在本地刷写近期的WAL与接收到后备服务器已经写入它（但还没有刷写或者应用）的通知之间流逝的时间。如果这台服务器被配置为一个同步后备，这可以用来计量在提交时synchronous_commit的级别remote_write所导致的延迟。   flush_lag interval 在本地刷写近期的WAL与接收到后备服务器已经写入并且刷写它（但还没有应用）的通知之间流逝的时间。如果这台服务器被配置为一个同步后备，这可以用来计量在提交时synchronous_commit的级别on所导致的延迟。   replay_lag interval 在本地刷写近期的WAL与接收到后备服务器已经写入它、刷写它并且应用它的通知之间流逝的时间。如果这台服务器被配置为一个同步后备，这可以用来计量在提交时synchronous_commit的级别remote_apply所导致的延迟。   sync_priority integer 在基于优先的同步复制中，这台后备服务器被选为同步后备的优先级。在基于规定数量的同步复制中，这个值没有效果。   sync_state text 这一台后备服务器的同步状态。 可能的值是：async：这台后备服务器是异步的。potential：这台后备服务器现在是异步的，但可能在当前的同步后备失效时变成同步的。sync：这台后备服务器是同步的。quorum：这台后备服务器被当做规定数量后备服务器的候选。   reply_time timestamp with time zone 从备用服务器收到的最后一条回复信息的发送时间    pg_stat_replication视图中报告的滞后时间近期的WAL被写入、刷写并且重放以及发送器知道这一切所花的时间的度量。如果远程服务器被配置为一台同步后备，这些时间表示由每一种同步提交级别所带来（或者是可能带来）的提交延迟。对于一台异步后备，replay_lag列是最近的事务变得对查询可见的延迟时间的近似值。如果后备服务器已经完全追上了发送服务器并且没有WAL活动，在短时间内将继续显示最近测到的滞后时间，再然后就会显示为NULL。\n对于物理复制会自动测量滞后时间。逻辑解码插件可能会选择性地发出跟踪消息，如果它们没有这样做，跟踪机制将把滞后显示为NULL。\n 报告的滞后时间并非按照当前的重放速率该后备还有多久才能追上发送服务器的预测。在新的WAL被生成期间，这样一种系统将显示类似的时间，但是当发送器变为闲置时会显示不同的值。特别是当后备服务器完全追上时，pg_stat_replication显示的是写入、刷写及重放最近报告的WAL位置所花的时间而不是一些用户可能预期的零。这种做法与为近期的写事务测量同步提交和事务可见性延迟的目的一致。为了降低用户预期一种不同的滞后模型带来的混淆，在一个完全重放完的闲置系统上，lag列会在一段比较短的时间后回复成NULL。监控系统应该选择将这种情况表示为缺失数据、零或者继续显示最近的已知值。  pg_stat_database     pg_stat_database视图将为集簇中的每一个数据库包含有一行，再加上一个共享对象，显示出全数据库的统计信息。\n表 16. pg_stat_database视图\n   列 类型 描述     datid oid 一个数据库的OID，或属于共享关系的对象为0。   datname name 此数据库的名称，或共享对象的NULL。   numbackends integer 当前连接到这个数据库的后端数量，或者NULL为共享对象。 这是此视图中唯一返回反映当前状态的值的列；所有其他列都返回上次重置后的累积值。   xact_commit bigint 在这个数据库中已经被提交的事务的数量   xact_rollback bigint 在这个数据库中已经被回滚的事务的数量   blks_read bigint 在这个数据库中被读取的磁盘块的数量   blks_cloned bigint 在这个数据库中构造用于一致性读的缓冲页的数量   blks_hit bigint 磁盘块被发现已经在缓冲区中的次数，这样不需要一次读取（这只包括 PostgreSQL 缓冲区中的命中，而不包括在操作系统文件系统缓冲区中的命中）   tup_returned bigint 在这个数据库中被查询返回的行数   tup_fetched bigint 在这个数据库中被查询取出的行数   tup_inserted bigint 在这个数据库中被查询插入的行数   tup_updated bigint 在这个数据库中被查询更新的行数   tup_deleted bigint 在这个数据库中被查询删除的行数   conflicts bigint 由于与恢复冲突而在这个数据库中被取消的查询的数目（冲突只发生在后备服务器上，详见pg_stat_database_conflicts）。   temp_files bigint 在这个数据库中被查询创建的临时文件的数量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管log_temp_files设置。   temp_bytes bigint 在这个数据库中被查询写到临时文件中的数据总量。所有临时文件都被统计，不管为什么创建这些临时文件（如排序或哈希），并且不管log_temp_files设置。   deadlocks bigint 在这个数据库中被检测到的死锁数   checksum_failures bigint 在此数据库（或共享对象上）检测到的数据页校验和失败的次数，如果没有启用数据校验和，则为NULL。   checksum_last_failure timestamp with time zone 在此数据库（或共享对象上）检测到最后一个数据页校验和失败的时间，如果没有启用数据校验和，则为NULL。   blk_read_time double precision 在这个数据库中后端花费在读取数据文件块的时间，以毫秒计   blk_clone_time double precision 在这个数据库中后端花费在构造用于一致性读的缓冲页的时间，以毫秒计   blk_write_time double precision 在这个数据库中后端花费在写数据文件块的时间，以毫秒计   stats_reset timestamp with time zone 这些统计信息上次被重置的时间    pg_stat_all_tables     pg_stat_all_tables视图将为当前数据库中的每一个表（包括 TOAST 表）包含一行，该行显示与对该表的访问相关的统计信息。pg_stat_user_tables和pg_stat_sys_tables视图包含相同的信息，但是被过滤得分别只显示用户和系统表。\n表 17. pg_stat_all_tables视图\n   列 类型 描述     relid oid 一个表的 OID   schemaname name 这个表所在的模式的名称   relname name 这个表的名称   seq_scan bigint 在这个表上发起的顺序扫描的次数   seq_tup_read bigint 被顺序扫描取得的活着的行的数量   idx_scan bigint 在这个表上发起的索引扫描的次数   idx_tup_fetch bigint 被索引扫描取得的活着的行的数量   n_tup_ins bigint 被插入的行数   n_tup_upd bigint 被更新的行数（包括 HOT 更新的行）   n_tup_del bigint 被删除的行数   n_tup_hot_upd bigint 被更新的 HOT 行数（即不要求独立索引更新的行更新）   n_live_tup bigint 活着的行的估计数量   n_dead_tup bigint 死亡行的估计数量   n_mod_since_analyze bigint 从这个表最后一次被分析后备修改的行的估计数量   last_analyze timestamp with time zone 上次这个表被手动分析的时间   last_autoanalyze timestamp with time zone 上次这个表被自动分析守护进程分析的时间   analyze_count bigint 这个表已被手工分析的次数   autoanalyze_count bigint 这个表已被自动分析守护进程分析的次数    pg_stat_all_undos     pg_stat_all_undos 视图将为当前数据库中的每一个回滚段包含一行，该行显示与对该回滚段的访问相关的统计信息。\n表 18. pg_stat_all_undos 视图\n   列 类型 描述     relid oid 一个回滚段的 OID   schemaname name 这个回滚段所在的模式的名称   relname name 这个回滚段的名称   n_tup_fetch bigint 被获取的活着的记录的数量   n_tup_ins bigint 被插入的记录数   n_tup_upd bigint 被更新的记录数   n_tup_del bigint 被删除的记录数   n_tup_hot_upd bigint 被更新的 HOT 记录数   n_live_tup bigint 活着的记录的估计数量   n_dead_tup bigint 死亡记录的估计数量    pg_stat_all_indexes     pg_stat_all_indexes视图将为当前数据库中的每个索引包含一行，该行显示关于对该索引访问的统计信息。pg_stat_user_indexes和pg_stat_sys_indexes视图包含相同的信息，但是被过滤得只分别显示用户和系统索引。\n表 19. pg_stat_all_indexes视图\n   列 类型 描述     relid oid 这个索引的基表的 OID   indexrelid oid 这个索引的 OID   schemaname name 这个索引所在的模式的名称   relname name 这个索引的基表的名称   indexrelname name 这个索引的名称   idx_scan bigint 在这个索引上发起的索引扫描次数   idx_tup_read bigint 在这个索引上由扫描返回的索引项数量   idx_tup_fetch bigint 被使用这个索引的简单索引扫描取得的活着的表行数量    索引可以被简单索引扫描、“位图”索引扫描以及优化器使用。在一次位图扫描中，多个索引的输出可以被通过 AND 或 OR 规则组合，因此当使用一次位图扫描时难以将取得的个体堆行与特定的索引关联起来。因此，一次位图扫描会增加它使用的索引的pg_stat_all_indexes.idx_tup_read计数，并且为每个表增加pg_stat_all_tables.idx_tup_fetch计数，但是它不影响pg_stat_all_indexes.idx_tup_fetch。如果所提供的常量值不在优化器统计信息记录的范围之内，优化器也会访问索引来检查，因为优化器统计信息可能已经“不新鲜”了。\n 即使不用位图扫描，idx_tup_read和idx_tup_fetch计数也可能不同，因为idx_tup_read统计从该索引取得的索引项而idx_tup_fetch统计从表取得的活着的行。如果使用该索引取得了任何死亡行或还未提交的行，或者如果通过一次只用索引扫描的方式避免了任何堆获取，后者将较小。  pg_statio_all_tables     pg_statio_all_tables视图将为当前数据库中的每个表（包括 TOAST 表）包含一行，该行显示指定表上有关 I/O 的统计信息。pg_statio_user_tables和pg_statio_sys_tables视图包含相同的信息，但是被过滤得分别只显示用户表和系统表。\n表 20. pg_statio_all_tables视图\n   列 类型 描述     relid oid 一个表的 OID   schemaname name 这个表所在的模式的名称   relname name 这个表的名称   heap_blks_read bigint 从这个表读取的磁盘块数量   heap_blks_clone bigint 从这个表构造用于一致性读的缓冲页数量   heap_blks_hit bigint 在这个表中的缓冲区命中数量   idx_blks_read bigint 从这个表上所有索引中读取的磁盘块数   idx_blks_clone bigint 从这个表上所有索引中构造用于一致性读的缓冲页数   idx_blks_hit bigint 在这个表上的所有索引中的缓冲区命中数量   toast_blks_read bigint 从这个表的 TOAST 表（如果有）读取的磁盘块数   toast_blks_clone bigint 从这个表的 TOAST 表（如果有）构造用于一致性读的缓冲页数   toast_blks_hit bigint 在这个表的 TOAST 表（如果有）中的缓冲区命中数量   tidx_blks_read bigint 从这个表的 TOAST 表索引（如果有）中读取的磁盘块数   tidx_blks_clone bigint 从这个表的 TOAST 表索引（如果有）中构造用于一致性读的缓冲页数   tidx_blks_hit bigint 在这个表的 TOAST 表索引（如果有）中的缓冲区命中数量    pg_statio_all_undos     pg_statio_all_undos视图将为当前数据库中的每个回滚段包含一行，该行显示指定回滚段上有关 I/O 的统计信息。\n表 21. pg_statio_all_undos 视图\n   Column Type Description     relid oid 一个回滚段的 OID   schemaname name 这个回滚段所在的模式的名称   relname name 这个回滚段的名称   undo_blks_read bigint 从这个回滚段读取的磁盘块数量   undo_blks_cloned bigint 从这个回滚段构造用于一致性读的缓冲页数量，主要涉及回滚段中的事务表访问   undo_blks_hit bigint 在这个回滚段中的缓冲区命中数量    pg_statio_all_indexes     pg_statio_all_indexes视图将为当前数据库中的每个索引包含一行，该行显示指定索引上有关 I/O 的统计信息。pg_statio_user_indexes和pg_statio_sys_indexes视图包含相同的信息，但是被过滤得分别只显示用户索引和系统索引。\n表 22. pg_statio_all_indexes视图\n   列 类型 描述     relid oid 这个索引的基表的 OID   indexrelid oid 这个索引的 OID   schemaname name 这个索引所在的模式的名称   relname name 这个索引的基表的名称   indexrelname name 这个索引的名称   idx_blks_read bigint 从这个索引读取的磁盘块数   idx_blks_clone bigint 从这个索引构造用于一致性读的缓冲页数   idx_blks_hit bigint 在这个索引中的缓冲区命中数量    pg_statio_all_sequences     pg_statio_all_sequences视图将为当前数据库中的每个序列包含一行，该行显示在指定序列上有关 I/O 的统计信息。\n表 23. pg_statio_all_sequences视图\n   列 类型 描述     relid oid 一个序列的 OID   schemaname name 这个序列所在的模式的名称   relname name 这个序列的名称   blks_read bigint 从这个序列中读取的磁盘块数   blks_clone bigint 从这个序列中构造用于一致性读的缓冲页数   blks_hit bigint 在这个序列中的缓冲区命中数量    "},{"id":18,"href":"/zh-cn/features/event-triggers/","title":"事件触发器","parent":"基础特性","content":"   事件触发器行为总览 事件触发器触发矩阵 事件触发器函数  在命令结束处捕捉更改 处理被 DDL 命令删除的对象 处理表重写事件 反解析 DDL 命令        Redrock Postgres 提供了事件触发器。和常规触发器（附着在一个表上并且只捕捉 DML 事件）不同，事件触发器对一个特定数据库来说是全局的，并且可以捕捉 DDL 事件。\n和常规触发器相似，可以用任何包括了事件触发器支持的过程语言或者 C 编写事件触发器，但是不能用纯 SQL 编写。\n事件触发器行为总览     只要与一个事件触发器相关的事件在事件触发器所在的数据库中发生，该事件触发器就会被引发。当前支持的事件是 ddl_command_start、ddl_command_end、 table_rewrite和sql_drop。未来的发行版中可能会增加对更多事件的支持。\nddl_command_start事件就在CREATE、 ALTER、DROP、SECURITY LABEL、 COMMENT、GRANT或者REVOKE 命令的执行之前发生。在事件触发器引发前不会做受影响对象是否存在的检查。不过，一个例外是，这个事件不会为目标是共享对象 — 数据库 — 的 DDL 命令发生，也不会为目标是事件触发器的 DDL 命令发生。事件触发器机制不支持这些对象类型。 ddl_command_start也会在SELECT INTO 命令的执行之前发生，因为这等价于 CREATE TABLE AS。\nddl_command_end事件就在同一组命令的执行之后发生。为了得到发生的DDL操作的更多细节，可以从 ddl_command_end事件触发器代码中使用集合返回函数 pg_event_trigger_ddl_commands()（见 事件触发器函数）。注意该触发器是在那些动作已经发生之后（但是在事务提交前）引发，并且因此系统目录会被读作已更改。\nsql_drop事件为任何删除数据库对象的操作在 ddl_command_end事件触发器之前发生。要列出已经被删除的对象，可以从sql_drop事件触发器代码中使用集合返回函数 pg_event_trigger_dropped_objects()见 事件触发器函数）。注意该触发器是在对象已经从系统目录删除以后执行，因此不能再查看它们。\ntable_rewrite事件在表被命令ALTER TABLE和 ALTER TYPE的某些动作重写之前发生。虽然其他控制语句（例如 CLUSTER和VACUUM）也可以用来重写表，但是它们不会触发table_rewrite事件。\n不能在一个中止的事务中执行事件触发器（其他函数也一样）。因此，如果一个 DDL 命令出现错误失败，将不会执行任何相关的 ddl_command_end触发器。反过来，如果一个 ddl_command_start触发器出现错误失败，将不会引发进一步的事件触发器，并且不会尝试执行该命令本身。类似地，如果一个 ddl_command_end触发器出现错误失败，DDL 命令的效果将被回滚，就像其他包含事务中止的情况中那样。\n事件触发器触发矩阵 中有事件触发器机制所支持的完整命令列表。\n事件触发器通过命令CREATE EVENT TRIGGER创建。为了创建一个事件触发器，你必须首先创建一个有特殊返回类型 event_trigger的函数。这个函数不一定需要返回一个值，该返回类型仅仅是作为一种信号表示该函数要被作为一个事件触发器调用。\n如果对于一个特定的事件定义了多于一个事件触发器，它们将按照触发器名称的字母表顺序被引发。\n一个触发器定义也可以指定一个WHEN条件，这样事件触发器（例如ddl_command_start触发器）就可以只对用户希望介入的特定命令触发。这类触发器的通常用法是用于限制用户可能执行的 DDL 操作的范围。\n事件触发器触发矩阵     表 1 列出了所有命令的事件触发器支持情况。\n表 1. 支持事件触发器的命令标签\n   命令标签 ddl_command_start ddl_command_end sql_drop table_rewrite 注解     ALTER AGGREGATE X X - -    ALTER COLLATION X X - -    ALTER CONVERSION X X - -    ALTER DOMAIN X X - -    ALTER DEFAULT PRIVILEGES X X - -    ALTER EXTENSION X X - -    ALTER FOREIGN DATA WRAPPER X X - -    ALTER FOREIGN TABLE X X X -    ALTER FUNCTION X X - -    ALTER LANGUAGE X X - -    ALTER LARGE OBJECT X X - -    ALTER MATERIALIZED VIEW X X - -    ALTER OPERATOR X X - -    ALTER OPERATOR CLASS X X - -    ALTER OPERATOR FAMILY X X - -    ALTER POLICY X X - -    ALTER PROCEDURE X X - -    ALTER PUBLICATION X X - -    ALTER ROLE X X - -    ALTER ROUTINE X X - -    ALTER SCHEMA X X - -    ALTER SEQUENCE X X - -    ALTER SERVER X X - -    ALTER STATISTICS X X - -    ALTER SUBSCRIPTION X X - -    ALTER TABLE X X X X    ALTER TABLESPACE X X - -    ALTER TEXT SEARCH CONFIGURATION X X - -    ALTER TEXT SEARCH DICTIONARY X X - -    ALTER TEXT SEARCH PARSER X X - -    ALTER TEXT SEARCH TEMPLATE X X - -    ALTER TRIGGER X X - -    ALTER TYPE X X - X    ALTER USER X X - -    ALTER USER MAPPING X X - -    ALTER VIEW X X - -    COMMENT X X - - 只对本地对象   CREATE ACCESS METHOD X X - -    CREATE AGGREGATE X X - -    CREATE CAST X X - -    CREATE COLLATION X X - -    CREATE CONVERSION X X - -    CREATE DOMAIN X X - -    CREATE EXTENSION X X - -    CREATE FOREIGN DATA WRAPPER X X - -    CREATE FOREIGN TABLE X X - -    CREATE FUNCTION X X - -    CREATE INDEX X X - -    CREATE LANGUAGE X X - -    CREATE MATERIALIZED VIEW X X - -    CREATE OPERATOR X X - -    CREATE OPERATOR CLASS X X - -    CREATE OPERATOR FAMILY X X - -    CREATE POLICY X X - -    CREATE PROCEDURE X X - -    CREATE PUBLICATION X X - -    CREATE ROLE X X - -    CREATE RULE X X - -    CREATE SCHEMA X X - -    CREATE SEQUENCE X X - -    CREATE SERVER X X - -    CREATE STATISTICS X X - -    CREATE SUBSCRIPTION X X - -    CREATE TABLE X X - -    CREATE TABLE AS X X - -    CREATE TABLESPACE X X - -    CREATE TEXT SEARCH CONFIGURATION X X - -    CREATE TEXT SEARCH DICTIONARY X X - -    CREATE TEXT SEARCH PARSER X X - -    CREATE TEXT SEARCH TEMPLATE X X - -    CREATE TRIGGER X X - -    CREATE TYPE X X - -    CREATE USER X X - -    CREATE USER MAPPING X X - -    CREATE VIEW X X - -    DROP ACCESS METHOD X X X -    DROP AGGREGATE X X X -    DROP CAST X X X -    DROP COLLATION X X X -    DROP CONVERSION X X X -    DROP DOMAIN X X X -    DROP EXTENSION X X X -    DROP FOREIGN DATA WRAPPER X X X -    DROP FOREIGN TABLE X X X -    DROP FUNCTION X X X -    DROP INDEX X X X -    DROP LANGUAGE X X X -    DROP MATERIALIZED VIEW X X X -    DROP OPERATOR X X X -    DROP OPERATOR CLASS X X X -    DROP OPERATOR FAMILY X X X -    DROP OWNED X X X -    DROP POLICY X X X -    DROP PROCEDURE X X X -    DROP PUBLICATION X X X -    DROP ROLE X X X -    DROP ROUTINE X X X -    DROP RULE X X X -    DROP SCHEMA X X X -    DROP SEQUENCE X X X -    DROP SERVER X X X -    DROP STATISTICS X X X -    DROP SUBSCRIPTION X X X -    DROP TABLE X X X -    DROP TABLESPACE X X X -    DROP TEXT SEARCH CONFIGURATION X X X -    DROP TEXT SEARCH DICTIONARY X X X -    DROP TEXT SEARCH PARSER X X X -    DROP TEXT SEARCH TEMPLATE X X X -    DROP TRIGGER X X X -    DROP TYPE X X X -    DROP USER X X X -    DROP USER MAPPING X X X -    DROP VIEW X X X -    GRANT X X - - 只对本地对象   IMPORT FOREIGN SCHEMA X X - -    REFRESH MATERIALIZED VIEW X X - -    REVOKE X X - - 只对本地对象   SECURITY LABEL X X - - 只对本地对象   SELECT INTO X X - -     事件触发器函数     Redrock Postgres提供了这些助手函数来从事件触发器检索信息。\n在命令结束处捕捉更改     当在一个ddl_command_end事件触发器的函数中调用时，pg_event_trigger_ddl_commands返回被每一个用户动作执行的DDL命令的列表。如果在其他任何环境中调用这个函数，会发生错误。 pg_event_trigger_ddl_commands为每一个被执行的基本命令返回一行，某些只有一个单一 SQL 句子的命令可能会返回多于一行。 这个函数返回下面的列：\n   名称 类型 描述     classid oid 对象所属的目录的 OID   objid oid 对象本身的 OID   objsubid integer 对象的子-id（例如列的属性号）   command_tag text 命令标签   object_type text 对象的类型   schema_name text 该对象所属的模式的名称（如果有），如果没有则为NULL。 没有引号。   object_identity text 对象标识的文本表现形式，用模式限定。如果必要，出现在 该标识中的每一个标识符都会被引用。   in_extension bool 如果该命令是一个扩展脚本的一部分则为真   command pg_ddl_command 以内部格式表达的该命令的一个完整表现形式。这不能被直接输出， 但是可以把它传递给其他函数来得到有关于该命令不同部分的信息。    处理被 DDL 命令删除的对象     pg_event_trigger_dropped_objects返回其sql_drop事件中命令所删除的所有对象的列表。如果在任何其他环境中被调用，pg_event_trigger_dropped_objects将抛出一个错误。pg_event_trigger_dropped_objects返回下列列：\n   名称 类型 描述     classid oid 对象所属的目录的 OID   objid oid 对象本身的 OID   objsubid integer 对象的子ID（如列的属性号）   original bool 如果这是删除中的一个根对象则为真   normal bool 指示在依赖图中有一个普通依赖关系指向该对象的标志   is_temporary bool 如果该对象是一个临时对象则为真   object_type text 对象的类型   schema_name text 对象所属模式的名称（如果存在）；否则为NULL。不应用引用。   object_name text 如果模式和名称的组合能被用于对象的一个唯一标识符，则是对象的名称；否则是NULL。不应用引用，并且名称不是模式限定的。   object_identity text 对象身份的文本表现，模式限定的。每一个以及所有身份中出现的标识符在必要时加引号。   address_names text[] 一个数组，它可以和object_type及 address_args 一起通过pg_get_object_address()函数在一台包含有同类相同名称对象的远程服务器上重建该对象地址。   address_args text[] 上述address_names的补充。    pg_event_trigger_dropped_objects可以被这样用在一个事件触发器中：\nCREATE FUNCTION test_event_trigger_for_drops() RETURNS event_trigger LANGUAGE plpgsql AS $$ DECLARE obj record; BEGIN FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects() LOOP RAISE NOTICE \u0026#39;% dropped object: % %.% %\u0026#39;, tg_tag, obj.object_type, obj.schema_name, obj.object_name, obj.object_identity; END LOOP; END $$; CREATE EVENT TRIGGER test_event_trigger_for_drops ON sql_drop EXECUTE PROCEDURE test_event_trigger_for_drops(); 处理表重写事件     表 2 中所示的函数提供刚刚被调用过table_rewrite 事件的表的信息。如果在任何其他环境中调用，会发生错误。\n表 2. 表重写信息\n   名称 返回类型 描述     pg_event_trigger_table_rewrite_oid() oid 要被重写的表的 OID。   pg_event_trigger_table_rewrite_reason() int 解释重写原因的原因代码。这些代码的确切含义在单独的文档中。    可以在一个这样的事件触发器中使用 pg_event_trigger_table_rewrite_oid函数：\nCREATE FUNCTION test_event_trigger_table_rewrite_oid() RETURNS event_trigger LANGUAGE plpgsql AS $$ BEGIN RAISE NOTICE \u0026#39;rewriting table % for reason %\u0026#39;, pg_event_trigger_table_rewrite_oid()::regclass, pg_event_trigger_table_rewrite_reason(); END; $$; CREATE EVENT TRIGGER test_table_rewrite_oid ON table_rewrite EXECUTE PROCEDURE test_event_trigger_table_rewrite_oid(); 反解析 DDL 命令     函数 pg_ddl_command_deparse 将一条DDL命令从 pg_ddl_command 类型的内部格式进行反向解析，并以 text类型的文本表示形式返回命令字符串。\n函数 pg_ddl_command_deparse 可用于事件触发器，如下所示：\nCREATE TABLE ddl_history( ord int, op_time timestamp, username text, command_tag text, object_type text, schema_name text, object_identity text, command text ); CREATE OR REPLACE FUNCTION ddl_trigger_func() RETURNS event_trigger SECURITY DEFINER AS $$ BEGIN INSERT INTO ddl_history SELECT ordinality, now(), current_user, command_tag, object_type, schema_name, object_identity, pg_ddl_command_deparse(command) FROM pg_event_trigger_ddl_commands() WITH ORDINALITY; END; $$ LANGUAGE plpgsql; CREATE EVENT TRIGGER deparse_event_trigger ON ddl_command_end EXECUTE PROCEDURE ddl_trigger_func(); "},{"id":19,"href":"/zh-cn/catalogs/","title":"系统表","parent":"欢迎访问红石数据库文档","content":"目录\n   pg_recyclebin      pg_ts_lexicon      pg_undo      系统表是关系型数据库存放模式元数据的地方，比如表和列的信息，以及内部统计信息等。Redrock Postgres 的系统表就是普通表。你可以删除并重建这些表、增加列、插入和更新数值， 然后彻底把你的系统搞垮。 通常情况下，我们不应该手工修改系统表，通常有SQL命令可以做这些事情。（例如，CREATE DATABASE 向 pg_database表插入一行 — 并且实际上在磁盘上创建该数据库。）。 有些比较深奥的操作例外，但是随着时间的流逝其中的很多也可以用 SQL 命令来完成，因此对系统表直接修改的需求也越来越小。\n"},{"id":20,"href":"/zh-cn/posts/","title":"新闻","parent":"欢迎访问红石数据库文档","content":""},{"id":21,"href":"/zh-cn/features/postgres-compatibility/","title":"同 PostgreSQL 的兼容性","parent":"基础特性","content":"   不支持的功能特性 同 PostgreSQL 的特性差异说明  用户 表空间 PID   不支持的配置参数 不支持的表存储参数      Redrock Postgres 是在 PostgreSQL 的基础上开发的，在客户端访问协议和SQL语法层面，Redrock Postgres 同 PostgreSQL 保持兼容。如果您的应用是基于 PostgreSQL 开发的，那么：\n 基于同 PostgreSQL 在客户端访问协议层面的二进制兼容，可以使用和 PostgreSQL 一样的各种编程语言驱动访问 Redrock Postgres，如：Java, C/C++, .Net, Python, Ruby, Perl, Go, ODBC等。 基于同 PostgreSQL 在SQL语法上的严格兼容，可以在应用软件不做任何改动的情况下迁移到 Redrock Postgres。 可以使用 PostgreSQL 相关的桌面管理工具访问 Redrock Postgres，如：DBeaver、pgAdmin 4、Navicat for PostgreSQL 等。  这意味着，在多数情况下，您可以使用 pg_dump 导出 PostgreSQL 中的数据，卸载 PostgreSQL 并安装 Redrock Postgres，将导出的数据导入到 Redrock Postgres 中，就可以开始了。\n不支持的功能特性      完全清理操作 冻结操作 系统列 中的 xmin，cmin，xmax，cmax 可序列化隔离级别 SP-GiST索引  同 PostgreSQL 的特性差异说明     用户     在 PostgreSQL 中，用户为集群级别的对象，而在 Redrock Postgres 中，用户为数据库级别的对象。这意味者，在你访问同一个集群中不同的数据库对象时，虽然可能会看到相同名字的用户，实际上，它们是分属于各自数据库中不同的用户对象。\n 该差异需要数据库管理员特别关注，对于应用开发人员不受影响。  表空间     在 PostgreSQL 中，表空间为集群级别的对象，而在 Redrock Postgres 中，表空间为数据库级别的对象。这意味者，在你访问同一个集群中不同的数据库对象时，虽然可能会看到相同名字的表空间，实际上，它们是分属于各自数据库中不同的表空间对象。\n 该差异需要数据库管理员特别关注，对于应用开发人员不受影响。  PID     在有些运行统计视图中（如：pg_stat_activity, pg_locks），存在名称为 pid 的字段。在 PostgreSQL 中，这些字段表示的是操作系统进程号，而在 Redrock Postgres 中，表示的是数据库进程号。\n 在 pg_stat_activity 视图中，存在名称为 spid 的字段，表示真实的操作系统进程号。  不支持的配置参数     如果您在配置文件 postgresql.conf 中使用了以下任何选项，则应将其删除或者重命名。\n vacuum_freeze_table_age vacuum_freeze_min_age vacuum_multixact_freeze_table_age vacuum_multixact_freeze_min_age vacuum_cleanup_index_scale_factor autovacuum 重命名为 autoanalyze log_autovacuum_min_duration 重命名为 log_autoanalyze_min_duration autovacuum_max_workers 重命名为 autoanalyze_max_workers autovacuum_naptime 重命名为 autoanalyze_naptime autovacuum_vacuum_threshold autovacuum_analyze_threshold 重命名为 autoanalyze_base_threshold autovacuum_vacuum_scale_factor autovacuum_analyze_scale_factor 重命名为 autoanalyze_scale_factor autovacuum_freeze_max_age autovacuum_multixact_freeze_max_age autovacuum_vacuum_cost_delay autovacuum_vacuum_cost_limit  不支持的表存储参数     如果您在表定义中使用了以下任何 存储参数，则应将其删除或者重命名。\n autovacuum_enabled, toast.autovacuum_enabled 重命名为 autoanalyze_enabled, toast.autoanalyze_enabled vacuum_index_cleanup, toast.vacuum_index_cleanup vacuum_truncate, toast.vacuum_truncate autovacuum_vacuum_threshold, toast.autovacuum_vacuum_threshold autovacuum_vacuum_scale_factor, toast.autovacuum_vacuum_scale_factor autovacuum_analyze_threshold 重命名为 autoanalyze_base_threshold autovacuum_analyze_scale_factor 重命名为 autoanalyze_scale_factor autovacuum_vacuum_cost_delay, toast.autovacuum_vacuum_cost_delay autovacuum_vacuum_cost_limit, toast.autovacuum_vacuum_cost_limit autovacuum_freeze_min_age, toast.autovacuum_freeze_min_age autovacuum_freeze_max_age, toast.autovacuum_freeze_max_age autovacuum_freeze_table_age, toast.autovacuum_freeze_table_age autovacuum_multixact_freeze_min_age, toast.autovacuum_multixact_freeze_min_age autovacuum_multixact_freeze_max_age, toast.autovacuum_multixact_freeze_max_age autovacuum_multixact_freeze_table_age, toast.autovacuum_multixact_freeze_table_age log_autovacuum_min_duration, toast.log_autovacuum_min_duration 重命名为 log_autoanalyze_min_duration, toast.log_autoanalyze_min_duration  "},{"id":22,"href":"/zh-cn/posts/initial-release/","title":"Redrock Postgres 版本 12.1-1 发布","parent":"新闻","content":"Redrock 开发团队向您郑重发布 Redrock Postgres 12 版本 12.1-1。\n红石数据库是一款基于 PostgreSQL 的关系型数据库管理系统，PostgreSQL 是由 PostgreSQL 全球开发组织开发的一款开源数据库。红石数据库主要为企业生产环境和多云环境部署而设计。\n欲了解更多信息，请访问网站。\n特性概览:\n 回滚段: 记录日志用于回滚数据的修改和事务 多租户: 在服务器上运行单个数据库实例，并为多个租户提供服务 网络表空间: 通过基于网络的表空间特性，实现数据库的计算和存储分离部署 多线程: 多线程数据库模型使服务器进程能够作为操作系统线程在单独的地址空间中执行 回收站: 提供可存放删除对象的回收站，以防止误操作 DDL事件跟踪: 可跟踪、记录、发布和订阅 DDL 操作  "},{"id":23,"href":"/zh-cn/commands/alterundo/","title":"ALTER UNDO","parent":"SQL 命令","content":"ALTER UNDO — 更改一个回滚段的定义\n语法     ALTER UNDO [ IF EXISTS ] name RENAME TO new_name\rALTER UNDO [ IF EXISTS ] name SET TABLESPACE tablespace_name\rALTER UNDO name OWNER TO { new_owner | CURRENT_USER | SESSION_USER }\rALTER UNDO [ IF EXISTS ] name SET ( storage_parameter = value [, ... ] )\rALTER UNDO [ IF EXISTS ] name RESET ( storage_parameter [, ... ] ) 描述     ALTER UNDO更改一个现有回滚段的定义。下面描述了几种子形式。 注意每个子形式所需的锁级别可能不同。除非显式说明，ACCESS EXCLUSIVE锁被持有。 列出多个子命令时，锁的持有将是任何子命令所需的最严格的子命令。\n  RENAME\nRENAME形式更改该回滚段的名称。这对已存储的数据没有影响。重命名回滚段取得一个 SHARE UPDATE EXCLUSIVE锁。\n  SET TABLESPACE\n这种形式更改该回滚段的表空间为指定的表空间，并且把与该回滚段相关联的数据文件移动到新的表空间中。要更改一个回滚段的表空间，你必须拥有该回滚段并且具有新表空间上的CREATE特权。\n  OWNER TO\n这种形式更改该回滚段的拥有者为指定的拥有者。要修改拥有者，你还必须是新拥有角色的一个直接或间接成员（注意超级用户自动拥有这些特权）。\n  SET ( storage_parameter=value [, ... ] )\n这种形式为该回滚段更改一个或者多个回滚段相关的存储参数。可用的参数详见 CREATE UNDO。注意这个命令不会立刻修改回滚段内容， 根据参数你可能需要用 VACUUM 清理回滚段来得到想要的效果。\n  RESET ( storage_parameter [, ... ] )\n这种形式把一个或者多个回滚段相关的存储参数重置为其默认值。正如 SET一样，可能需要一次VACUUM来清理该回滚段。\n  参数       IF EXISTS\n如果该回滚段不存在不要抛出错误。这种情况下将发出一个提示。\n  name\n要更改的一个现有回滚段的名称（可能被模式限定）。\n  new_name\n该回滚段的新名称。\n  tablespace_name\n该回滚段将被移动到的表空间。\n  new_owner\n该回滚段的新拥有者。\n  storage_parameter\n一个回滚段相关的存储参数的名称。\n  value\n一个回滚段相关的存储参数的新值。根据该参数，这可能是一个数字或者一个词。\n  示例     要重命名一个现有回滚段：\nALTER UNDO undo_abc RENAME TO undo_test; 把一个回滚段移动到一个不同的表空间：\nALTER UNDO undo_15 SET TABLESPACE undospace; 更改一个回滚段的最小页面数：\nALTER UNDO undo_15 SET (minpages = 131072); 更改回滚段undo_15的拥有者：\nALTER UNDO undo_15 OWNER TO mary; 兼容性     ALTER UNDO是一种 Redrock Postgres 扩展。\n"},{"id":24,"href":"/zh-cn/commands/createundo/","title":"CREATE UNDO","parent":"SQL 命令","content":"CREATE UNDO — 定义一个新回滚段\n语法     CREATE UNDO [ IF NOT EXISTS ] name\r[ WITH ( storage_parameter = value [, ... ] ) ]\r[ TABLESPACE tablespace_name ] 描述     CREATE UNDO在当前数据库中构建一个回滚段。该回滚段名必须与当前数据库中任何现有回滚段的名称不同。回滚段主要被用来存放表和索引中修改过的老版本数据。\n要创建一个回滚段，你必须是一个超级用户或者当前数据库拥有者。\n参数       IF NOT EXISTS\n如果一个同名关系已经存在则不要抛出错误。这种情况下会发出一个提示。 注意这并不保证现有的回滚段与将要创建的回滚段有任何相似。\n  name\n要创建的回滚段名称。这里不能包括模式名，因为回滚段总是被创建在系统模式 pg_catalog 中。\n  storage_parameter\n回滚段相关的存储参数的名称。详见 回滚段存储参数。\n  tablespace_name\n在其中创建回滚段的表空间。如果没有指定，将会使用 default_tablespace。\n  回滚段存储参数     可选的WITH子句为回滚段指定存储参数：\n  initialpages\n回滚段中的初始页面数。默认是128。\n  minpages\n回滚段中的最小页面数。默认是128。\n  maxpages\n回滚段中的最大页面数。默认不限制。该参数更多只是一种提示，实际上，Redrock Postgres 采用的是一种完全自动化的机制，称为自动回滚段管理模式，用于管理回滚段占用的存储空间。\n  备注     初始化数据库集群数据目录后，数据库中默认会产生4个集群级回滚段和8个数据库级别的回滚段，其中集群级回滚段主要用来修改共享系统表的数据，如 pg_database。回滚段的首个页面用于存储事务表项信息，单个回滚段同时最多能存放约200个事务项。\n但是，如果单个回滚段同时处理的事务数较多（比如超过8个），会因为事务表并发访问冲突产生对应的页面访问等待事件。此时，就可以使用 CREATE UNDO 命令在当前数据库中创建更多的回滚段，以提升系统的事务处理性能。\n示例     创建一个回滚段：\nCREATE UNDO undo_13; 创建一个回滚段并且把回滚段放在表空间undospace中：\nCREATE UNDO undo_14 TABLESPACE undospace; 兼容性     CREATE UNDO是一种 Redrock Postgres 的语言扩展。在 SQL 标准中没有对于回滚段的规定。\n"},{"id":25,"href":"/zh-cn/commands/dropundo/","title":"DROP UNDO","parent":"SQL 命令","content":"DROP UNDO — 删除一个回滚段\n语法     DROP UNDO [ IF EXISTS ] name [, ...] [ CASCADE | RESTRICT ] 描述     DROP UNDO从数据库系统中删除一个已有的回滚段。要执行这个命令你必须是该回滚段的拥有者。\n参数       IF EXISTS\n如果该回滚段不存在则不要抛出一个错误，而是发出一个提示。\n  name\n要删除的回滚段的名称（可以是模式限定的）。\n  CASCADE\n自动删除依赖于该回滚段的对象，然后删除所有依赖于那些对象的对象（见第 5.14 节）。\n  RESTRICT\n如果有任何对象依赖于该回滚段，则拒绝删除它。这是默认值。\n  示例     这个命令将删除回滚段undo_15：\nDROP UNDO undo_15; 兼容性     DROP UNDO是一个 Redrock Postgres 语言扩展。在 SQL 标准中没有提供回滚段。\n"},{"id":26,"href":"/zh-cn/catalogs/recyclebin/","title":"pg_recyclebin","parent":"系统表","content":"目录 pg_recyclebin 记录数据库中已删除对象的部分信息。其他信息大部分在 pg_class、pg_type、pg_proc 和 pg_constraint 中。\n表. pg_recyclebin的列\n   名称 类型 引用 描述     classid oid pg_class.oid 已删除对象所在的系统目录OID   objid oid 任意OID列 已删除对象的OID   objsubid oid  当 classid 为系统表 pg_namespace 的OID时，表示模式拥有者的用户OID。对于所有其他对象类型，此列为0。   namespace oid pg_namespace.oid 已删除对象所在的模式OID   objname name 任意NAME列 该对象被删除后的新名称   oldname name 任意NAME列 该对象被删除前的名称   command char  该对象被删除的触发操作： d - DROP操作 r - 重写操作，如：ALTER TABLE  t - TRUNCATE操作   droptime timestamptz  该对象被删除的时间    "},{"id":27,"href":"/zh-cn/catalogs/ts-lexicon/","title":"pg_ts_lexicon","parent":"系统表","content":"目录pg_ts_lexicon包含关于用于中文解析的词典信息。\n表. pg_ts_lexicon的列\n   名称 类型 描述     lexfreq int4 该词语在文本中出现的频率统计值   lextype int2 该词语的类型。可能的值有：0: 中文词语1: 中文单位2: 英中混合词语3: 中英混合词语4: 中文姓氏5: 中文单姓名6: 中文双姓名首字7: 中文双姓名尾字8: 中文姓氏修饰词9: 停顿词10: 英文标点符混合词语11: 英文词语15: 其他词语16: 同义词语17: 标点符号   lexkind char 该词语在语句中的词性，包括: 名词 (n)，代名词 (p)，形容词 (a)，副词 (d)，动词 (v)，数词 (m)，冠词 (t)，介词 (r)，连接词 (c)，感叹词 (i)   lexword text 该词语的文字表示   lexsynonyms text[] 该词语的同义词列表    "},{"id":28,"href":"/zh-cn/catalogs/undo/","title":"pg_undo","parent":"系统表","content":"目录pg_undo包含关于回滚段的部分信息。其他信息大部分在pg_class中。\n表. pg_undo的列\n   名称 类型 描述     undoid oid 此回滚段的编号，系统从1开始顺序分配   undrelid oid 此回滚段的pg_class项的OID   undusecount int8 此回滚段中事务表项被重用的次数，该字段只有在一个回滚段被删除时才会更新   undreusetime logicaltime 此回滚段中事务表项被重用时的逻辑时间戳，该字段只有在一个回滚段被删除时才会更新   undisvalid bool 如果为真，此回滚段当前可以用于提供读一致性。为假表示此回滚段已被彻底删除   undislive bool 如果为假，此回滚段已被删除    "},{"id":29,"href":"/zh-cn/tags/","title":"Tags","parent":"欢迎访问红石数据库文档","content":""},{"id":30,"href":"/zh-cn/commands/vacuum/","title":"VACUUM","parent":"SQL 命令","content":"VACUUM — 清理一个数据库\n语法     VACUUM [ ( option [, ...] ) ] [ name [, ...] ]\rVACUUM [ VERBOSE ] [ name [, ...] ]\r其中option可以是下列之一：\rVERBOSE [ boolean ]\rSKIP_LOCKED [ boolean ]\rTRUNCATE [ boolean ] 描述     VACUUM可以用来执行以下操作：\n 尝试截断表末尾的任何空页，并允许将截断页的磁盘空间返回到操作系统 尝试收缩回滚段 清理回收站中的已删除对象  在没有*name*列表的情况下，VACUUM会处理当前用户具有清理权限的当前数据库中的每一个表、物化视图、回滚段，和回收站中的已删除对象。如果给出一个列表，VACUUM可以只处理列表中的那些表。\n当选项列表被包围在圆括号中时，选项可以被写成任何顺序。如果没有圆括号，选项必须严格按照上面所展示的顺序指定。\n参数       VERBOSE\n为每个表打印一份详细的清理活动报告。\n  SKIP_LOCKED\n规定VACUUM在开始处理关系时不等待任何冲突锁被释放：如果关系不能立即锁定而不等待，则跳过关系。 请注意即使采用此选项，VACUUM在打开关系的索引时仍可能阻塞。还有，虽然VACUUM通常处理指定分区表的所有分区，但如果分区表上的锁冲突， 此选项将导致VACUUM跳过所有分区。\n  TRUNCATE\n指定VACUUM尝试截断表末尾的任何空页，并允许将截断页的磁盘空间返回到操作系统。 这通常是所需的行为，并且是默认行为，除非将vacuum_truncate选项设置为 false，对要被清空的表。 将此选项设置为 false 可能有助于避免ACCESS EXCLUSIVE锁定需要截断的表。\n  boolean\n指定打开还是关闭所选选项。你可以写入TRUE、ON或1以启用该选项，以及FALSE、OFF或0来禁用它。 在TRUE被假定的情况下，boolean 值也可以被省略。\n  name\n要清理的表、物化视图或者回滚段的名称（可以有模式修饰）。如果指定的表示一个分区表，则它所有的叶子分区也会被清理。\n  输出     如果声明了VERBOSE，VACUUM会发出进度消息来表明当前正在处理哪个表。各种有关这些表的统计信息也会打印出来。\n注意     要清理一个表，操作者通常必须是表的拥有者或者超级用户。但是，数据库拥有者被允许清理他们的数据库中除了共享目录之外的所有表（对于共享目录的限制意味着一个真正的数据库范围的VACUUM只能被超级用户执行）。VACUUM将会跳过执行者不具备清理权限的表。\nVACUUM不能在一个事务块内被执行。\n例子     清理单一表onek，并且打印出详细的清理活动报告：\nVACUUM (VERBOSE) onek; 兼容性     在SQL标准中没有VACUUM语句。\n"},{"id":31,"href":"/zh-cn/","title":"欢迎访问红石数据库文档","parent":"","content":"红石数据库是一款基于 PostgreSQL 的关系型数据库管理系统，PostgreSQL是由 PostgreSQL全球开发组织开发的一款开源数据库。 红石数据库主要为企业生产环境和多云环境部署而设计。\n开始上手   特性概览   回滚段   记录日志用于回滚数据的修改和事务  多租户   在服务器上运行单个数据库实例，并为多个租户提供服务  网络表空间   基于网络表空间特性，实现数据库的计算和存储分离部署   多线程   单个系统进程中有多个工作线程，CPU调度时上下文切换的开销更少  回收站   提供可存放删除对象的回收站，以防止误操作  DDL事件跟踪   可跟踪、审计、发布和订阅 DDL 操作   "}]