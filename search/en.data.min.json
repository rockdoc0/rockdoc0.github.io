[{"id":0,"href":"/usage/getting-started/","title":"Getting Started","parent":"Usage","content":"   Installation Architectural Fundamentals Accessing Database Whats next?      Installation     Before you can use PostgreSQL you need to install it, of course. It is possible that PostgreSQL is already installed at your site, either because it was included in your operating system distribution or because the system administrator already installed it. If that is the case, you should obtain information from the operating system documentation or your system administrator about how to access PostgreSQL.\nIf you are not sure whether PostgreSQL is already available or whether you can use it for your experimentation then you can install it yourself. Doing so is not hard and it can be a good exercise. PostgreSQL can be installed by any unprivileged user; no superuser (root) access is required.\nIf you are installing PostgreSQL yourself, then refer to Chapter 17 for instructions on installation, and return to this guide when the installation is complete. Be sure to follow closely the section about setting up the appropriate environment variables.\nIf your site administrator has not set things up in the default way, you might have some more work to do. For example, if the database server machine is a remote machine, you will need to set the PGHOST environment variable to the name of the database server machine. The environment variable PGPORT might also have to be set. The bottom line is this: if you try to start an application program and it complains that it cannot connect to the database, you should consult your site administrator or, if that is you, the documentation to make sure that your environment is properly set up. If you did not understand the preceding paragraph then read the next section.\nArchitectural Fundamentals     Before we proceed, you should understand the basic PostgreSQL system architecture. Understanding how the parts of PostgreSQL interact will make this chapter somewhat clearer.\nIn database jargon, PostgreSQL uses a client/server model. A PostgreSQL session consists of the following cooperating processes (programs):\n A server process, which manages the database files, accepts connections to the database from client applications, and performs database actions on behalf of the clients. The database server program is called postgres. The user\u0026rsquo;s client (frontend) application that wants to perform database operations. Client applications can be very diverse in nature: a client could be a text-oriented tool, a graphical application, a web server that accesses the database to display web pages, or a specialized database maintenance tool. Some client applications are supplied with the PostgreSQL distribution; most are developed by users.  As is typical of client/server applications, the client and the server can be on different hosts. In that case they communicate over a TCP/IP network connection. You should keep this in mind, because the files that can be accessed on a client machine might not be accessible (or might only be accessible using a different file name) on the database server machine.\nThe PostgreSQL server can handle multiple concurrent connections from clients. To achieve this it starts (“forks”) a new process for each connection. From that point on, the client and the new server process communicate without intervention by the original postgres process. Thus, the supervisor server process is always running, waiting for client connections, whereas client and associated server processes come and go. (All of this is of course invisible to the user. We only mention it here for completeness.)\nAccessing Database     Once you have created a database, you can access it by:\n Running the PostgreSQL interactive terminal program, called psql, which allows you to interactively enter, edit, and execute SQL commands. Using an existing graphical frontend tool like pgAdmin or an office suite with ODBC or JDBC support to create and manipulate a database. These possibilities are not covered in this tutorial. Writing a custom application, using one of the several available language bindings. These possibilities are discussed further in Part IV.  You probably want to start up psql to try the examples in this tutorial. It can be activated for the postgres database by typing the command:\n$ psql postgres If you do not supply the database name then it will default to your user account name.\nIn psql, you will be greeted with the following message:\npsql (12.1) Type \u0026#34;help\u0026#34; for help. postgres=\u0026gt; The last line could also be:\npostgres=# That would mean you are a database superuser, which is most likely the case if you installed the PostgreSQL instance yourself. Being a superuser means that you are not subject to access controls. For the purposes of this tutorial that is not important.\nThe last line printed out by psql is the prompt, and it indicates that psql is listening to you and that you can type SQL queries into a work space maintained by psql. Try out these commands:\npostgres=\u0026gt; SELECT version(); version ------------------------------------------------------------------------------------------ PostgreSQL 12.1 on x86_64-pc-linux-gnu, compiled by gcc (Debian 4.9.2-10) 4.9.2, 64-bit (1 row) postgres=\u0026gt; SELECT current_date; date ------------ 2016-01-07 (1 row) postgres=\u0026gt; SELECT 2 + 2; ?column? ---------- 4 (1 row) The psql program has a number of internal commands that are not SQL commands. They begin with the backslash character, “\\”. For example, you can get help on the syntax of various PostgreSQL SQL commands by typing:\npostgres=\u0026gt; \\h To get out of psql, type:\npostgres=\u0026gt; \\q and psql will quit and return you to your command shell. (For more internal commands, type \\? at the psql prompt.) The full capabilities of psql are documented in psql. In this tutorial we will not use these features explicitly, but you can use them yourself when it is helpful.\nWhats next?     There are a lot more things to discover. To get more information, please refer to PostgreSQL Documentation.\n"},{"id":1,"href":"/installation/windows/","title":"Installing on Windows","parent":"Installation","content":"To perform an installation using the graphical installation wizard, you must have superuser or administrator privileges.\nThe following section walks you through installing PostgreSQL on a Windows host.\nTo start the installation wizard, assume sufficient privileges and double-click the installer icon; if prompted, provide a password.\nNote that in some versions of Windows, to invoke the installer with Administrator privileges, you need to right-click on the installer icon and select Run as Administrator from the context menu.\nThe Redrock 12 Setup Welcome window opens. Click Next to continue.\n    Fig. 1: The Redrock 12 Setup Welcome dialog    The Choose Install Location window opens. Accept the default installation directory, or specify an alternate location and click Next to continue.\n    Fig. 2: Choose Install Location dialog    Click Next to continue.\nThe Choose Data Directory window opens. Accept the default location or specify the name of the alternate directory in which you wish to store the data files.\n    Fig. 3: Choose Data Directory dialog    Click Next to continue.\nThe Server Options window opens.\n    Fig. 4: The Server Options dialog    PostgreSQL uses the Port field to specify the port number on which the server should listen. The default listener port is 5432.\nUse the Locale field to specify the locale that will be used by the new database cluster. The Default is the operating system locale.\nUse the Superuser field to specify the database superuser name. The default superuser name is postgres.\nUse the Password field to specify the database superuser password. The specified password should conform to enough complexities. After entering a password in the Password field, and confirming the password in the Retype Password field.\nClick Next to continue.\n    Fig. 5: Setting Configuration Parameters dialog    The Setting Configuration Parameters dialog will guides you to optimize server performance by setting some important configuration parameters. Maybe you can let the installer tune configuration parameters automatically, and click Next to continue.\n    Fig. 6: The Choose Start Menu Folder    During the installation, the setup wizard confirms the installation progress of PostgreSQL via a series of progress bars.\n    Fig. 7: The Installing dialog    When the Completing Redrock 12 Setup window appears, Congratulations! Click Finish to complete the PostgreSQL installation.\n    Fig. 8: Completing Redrock 12 Setup    "},{"id":2,"href":"/usage/","title":"Usage","parent":"Welcome to Redrock Documentation","content":""},{"id":3,"href":"/installation/","title":"Installation","parent":"Welcome to Redrock Documentation","content":""},{"id":4,"href":"/features/","title":"Features","parent":"Welcome to Redrock Documentation","content":""},{"id":5,"href":"/installation/redhat/","title":"Installing on Red Hat","parent":"Installation","content":"   Install RPM packages Post-installation commands  Data Directory Change Data Directory Initialize Startup   Control service After installation      Install RPM packages     Download the Redrock Postgres Package for Red Hat Enterprise Linux or CentOS, please use the following command to install:\n# tar xf redrock-12.1-1.el8.x86_64-bundle.tar # cd redrock-12.1-1.el8.x86_64-bundle # rpm -ivh redrock-12.1-1.el8.x86_64.rpm redrock-libs-12.1-1.el8.x86_64.rpm redrock-server-12.1-1.el8.x86_64.rpm Other packages can be installed according to your needs.\nPost-installation commands     After installing the packages, a database needs to be initialized and configured.\nIn the commands below, the value of  includes the major version of PostgreSQL, e.g., 12\nData Directory     The PostgreSQL data directory contains all of the data files for the database. The variable PGDATA is used to reference this directory.\nThe default data directory is:\n/var/lib/pgsql/\u0026lt;version\u0026gt;/data For example:\n/var/lib/pgsql/12/data Change Data Directory     Go to custom mount point (eg: /u01) and create a folder pgdata with postgres permissions:\n# cd /u01 # mkdir pgdata # chown postgres:postgres pgdata Then, edit the postgresql service:\n# systemctl edit postgresql-12.service Go to the custom mount point that has the majority of the disk space, copy and paste the following into that file:\n[Service] Environment=PGDATA=/u01/pgdata Initialize     The first command (only needed once) is to initialize the database in PGDATA.\nIf the previous command did not work, try directly calling the setup binary, located in a similar naming scheme:\n$ /usr/pgsql-\u0026lt;version\u0026gt;/bin/postgresql-\u0026lt;version\u0026gt;-setup initdb For versions 12, use:\n$ /usr/pgsql-12/bin/postgresql-12-setup initdb Startup     If you want PostgreSQL to start automatically when the OS starts, do the following:\n# systemctl enable postgresql-12.service Control service     To control the database service, use:\n# systemctl \u0026lt;command\u0026gt; postgresql-12.service where  can be:\n enable : enable automatical start start : start the database stop : stop the database restart : stop/start the database; used to read changes to core configuration files reload : reload configuration files while keeping database running  E.g. to control version 12 database service, use:\n# systemctl enable postgresql-12.service # systemctl start postgresql-12.service After installation     Modify the pg_hba.conf file in //pgdata/ to define what authentication method should be used from all networks to the PostgreSQL server and modify the localhost authentication method (change from indent to md5 and change from localhost to accept all incoming requests). Find the lines below:\n# IPv4 local connections: host all all 127.0.0.1/32 ident And change it to:\n# IPv4 local connections: host all all 0.0.0.0/0 md5 Modify the postgresql.conf (also in //pgdata/ ) file to allow connections from all hosts by uncommenting the following and adding an * instead of localhost:\nlisten_addresses = \u0026#39;*\u0026#39; Restart the database service to reload configurations:\n# systemctl restart postgresql-12.service In a production environment, you should also set up TLS-secured communication, and you should consider setting up data replication or snapshot-based backups. Consult the PostgreSQL online manual for these settings.\n"},{"id":6,"href":"/advanced/","title":"Advanced","parent":"Welcome to Redrock Documentation","content":""},{"id":7,"href":"/usage/configuration/","title":"Configuration","parent":"Usage","content":"Overview of all available server configuration options provided by the database.\n   Automatic Analyzing Run-time Statistics      Automatic Analyzing     These settings control the behavior of the autoanalyze feature. Refer to Section 24.1.6 for more information. Note that many of these settings can be overridden on a per-table basis; see Storage Parameters.\n  autoanalyze (boolean)\nControls whether the server should run the autoanalyze launcher daemon. This is on by default; however, track_counts must also be enabled for autoanalyze to work. This parameter can only be set in the postgresql.conf file or on the server command line; however, autoanalyzing can be disabled for individual tables by changing table storage parameters.\n  log_autoanalyze_min_duration (integer)\nCauses each action executed by autoanalyze to be logged if it ran for at least the specified amount of time. Setting this to zero logs all autoanalyze actions. -1 (the default) disables logging autoanalyze actions. If this value is specified without units, it is taken as milliseconds. For example, if you set this to 250ms then all automatic analyzes that run 250ms or longer will be logged. In addition, when this parameter is set to any value other than -1, a message will be logged if an autoanalyze action is skipped due to a conflicting lock or a concurrently dropped relation. Enabling this parameter can be helpful in tracking autoanalyze activity. This parameter can only be set in the postgresql.conf file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.\n  autoanalyze_max_workers (integer)\nSpecifies the maximum number of autoanalyze processes (other than the autoanalyze launcher) that may be running at any one time. The default is three. This parameter can only be set at server start.\n  autoanalyze_naptime (integer)\nSpecifies the minimum delay between autoanalyze runs on any given database. In each round the daemon examines the database and issues ANALYZE commands as needed for tables in that database. If this value is specified without units, it is taken as seconds. The default is one minute (1min). This parameter can only be set in the postgresql.conf file or on the server command line.\n  autoanalyze_base_threshold (integer)\nSpecifies the minimum number of inserted, updated or deleted tuples needed to trigger an ANALYZE in any one table. The default is 50 tuples. This parameter can only be set in the postgresql.conf file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.\n  autoanalyze_scale_factor (floating point)\nSpecifies a fraction of the table size to add to autoanalyze_base_threshold when deciding whether to trigger an ANALYZE. The default is 0.1 (10% of table size). This parameter can only be set in the postgresql.conf file or on the server command line; but the setting can be overridden for individual tables by changing table storage parameters.\n  Run-time Statistics     These parameters control server-wide statistics collection features. When statistics collection is enabled, the data that is produced can be accessed via the pg_stat and pg_statio family of system views. Refer to Chapter 27 for more information.\n  track_wait_events (boolean)\nEnables the collection of information on the wait events occured in each session, include occured times and timing information. This parameter is on by default. Note that even when enabled, this information is not visible to all users, only to superusers and the user owning the session being reported on, so it should not represent a security risk. Only superusers can change this setting.\n "},{"id":8,"href":"/installation/debian/","title":"Installing on Debian","parent":"Installation","content":"   Install DEB packages Post-installation commands  Data Directory Change Data Directory Initialize Startup   Control service After installation      Install DEB packages     Download the Redrock Postgres Package for Debian, please use the following command to install:\n# tar xf redrock-12.1-1.debian11.amd64-bundle.tar # cd redrock-12.1-1.debian11.amd64-bundle # dpkg -i redrock-client_12.1-1_amd64.deb redrock_12.1-1_amd64.deb Other packages can be installed according to your needs.\nPost-installation commands     After installing the packages, a database needs to be initialized and configured.\nIn the commands below, the value of  includes the major version of PostgreSQL, e.g., 12\nData Directory     The PostgreSQL data directory contains all of the data files for the database. The variable PGDATA is used to reference this directory.\nThe default data directory is:\n/var/lib/pgsql/\u0026lt;version\u0026gt;/data For example:\n/var/lib/pgsql/12/data Change Data Directory     Go to custom mount point (eg: /u01) and create a folder pgdata with postgres permissions:\n# cd /u01 # mkdir pgdata # chown postgres:postgres pgdata Then, edit the postgresql service:\n# systemctl edit postgresql-12.service Go to the custom mount point that has the majority of the disk space, copy and paste the following into that file:\n[Service] Environment=PGDATA=/u01/pgdata Initialize     The first command (only needed once) is to initialize the database in PGDATA.\nIf the previous command did not work, try directly calling the setup binary, located in a similar naming scheme:\n$ /usr/pgsql-\u0026lt;version\u0026gt;/bin/postgresql-\u0026lt;version\u0026gt;-setup initdb For versions 12, use:\n$ /usr/pgsql-12/bin/postgresql-12-setup initdb Startup     If you want PostgreSQL to start automatically when the OS starts, do the following:\n# systemctl enable postgresql-12.service Control service     To control the database service, use:\n# systemctl \u0026lt;command\u0026gt; postgresql-12.service where  can be:\n enable : enable automatical start start : start the database stop : stop the database restart : stop/start the database; used to read changes to core configuration files reload : reload configuration files while keeping database running  E.g. to control version 12 database service, use:\n# systemctl enable postgresql-12.service # systemctl start postgresql-12.service After installation     Modify the pg_hba.conf file in //pgdata/ to define what authentication method should be used from all networks to the PostgreSQL server and modify the localhost authentication method (change from indent to md5 and change from localhost to accept all incoming requests). Find the lines below:\n# IPv4 local connections: host all all 127.0.0.1/32 ident And change it to:\n# IPv4 local connections: host all all 0.0.0.0/0 md5 Modify the postgresql.conf (also in //pgdata/ ) file to allow connections from all hosts by uncommenting the following and adding an * instead of localhost:\nlisten_addresses = \u0026#39;*\u0026#39; Restart the database service to reload configurations:\n# systemctl restart postgresql-12.service In a production environment, you should also set up TLS-secured communication, and you should consider setting up data replication or snapshot-based backups. Consult the PostgreSQL online manual for these settings.\n"},{"id":9,"href":"/advanced/plscheme/","title":"PL/Scheme","parent":"Advanced","content":"PL/scheme is a PostgreSQL procedural language handler for Scheme programming language. PL/scheme uses Chibi Scheme in the background as its Scheme interpreter. With lots of builtin SRFIs and complete R7RS compliancy of Chibi Scheme, PL/scheme can power up PostgreSQL procedures in a Lisp style.\nFeatures     You can find some of the supported features by PL/scheme in the below list.\n Extensible native type support even for not created yet SQL data types. Domain, complex (ie. table\u0026rsquo;s row) and pseudo (record) types are supported as well. IN, INOUT and OUT argument mode functionality, Caching for non-volatile (and non-SRF) procedures per [top] transaction, and any available feature supported by Chibi Scheme (fully R7RS compliancy, module system extension, full access to POSIX system calls, networking support, multiple threads, powerful string processing, lots of builtin SRFIs and may others) are naturally shipped with PL/scheme too.  "},{"id":10,"href":"/features/undo/","title":"Undo","parent":"Features","content":"Redrock Postgres maintains records of the actions of transactions, collectively known as undo data. Redrock Postgres uses undo to do the following:\n Roll back an active transaction Recover a terminated transaction Provide read consistency  Redrock Postgres stores undo data inside the database rather than in external logs. Undo data is stored in blocks that are updated just like data blocks, with changes to these blocks generating redo. In this way, Redrock Postgres can efficiently access undo data without needing to read external logs.\nUndo data is stored in an independent tablespace. Redrock Postgres provides a fully automated mechanism, known as automatic undo management mode, for managing undos and space.\nUndos and Transactions     When a transaction starts, the database binds (assigns) the transaction to an undo segment, and therefore to a transaction table.\nMultiple active transactions can write concurrently to the same undo or to different undos. For example, transactions T1 and T2 can both write to undo U1, or T1 can write to U1 while T2 writes to undo U2.\nTransaction Rollback     When a ROLLBACK statement is issued, the database uses undo records to roll back changes made to the database by the uncommitted transaction. During recovery, the database rolls back any uncommitted changes applied from the online redo log to the data files. Undo records provide read consistency by maintaining the before image of the data for users accessing data at the same time that another user is changing it.\n"},{"id":11,"href":"/posts/","title":"News","parent":"Welcome to Redrock Documentation","content":""},{"id":12,"href":"/posts/initial-release/","title":"Redrock Postgres version 12.1-1 Released","parent":"News","content":"The Redrock Development Team is pleased to announce Redrock Postgres 12 version 12.1-1.\nRedrock is an object-relational database management system (ORDBMS) based on PostgreSQL, developed by the PostgreSQL Global Development Group. It is intentionally designed as an enterprise grade and cloud native database.\nFor more information, please see the website.\nFeature overview:\n Undo: Log record for roll back modified data and transactions. Multitenant: Single database instance runs on a server and serves multiple tenants. Network based tablespace: Devide computing and storage functions in database through network based tablespace. Multithread: The multithreaded database model enables server processes to execute as operating system threads in separate address spaces. Recyclebin: Provide recycle bin to reserve dropped objects to prevent mistake. DDL event tracking: Tracking, recording, publishing and subscribing DDL operations.  "},{"id":13,"href":"/_includes/","title":"Includes","parent":"Welcome to Redrock Documentation","content":""},{"id":14,"href":"/_includes/include-page/","title":"Include Page","parent":"Includes","content":"Example page include\n Example Shortcode\nShortcode used in an include page.     Head 1 Head 2 Head 3     1 2 3    "},{"id":15,"href":"/tags/","title":"Tags","parent":"Welcome to Redrock Documentation","content":""},{"id":16,"href":"/","title":"Welcome to Redrock Documentation","parent":"","content":"Redrock is an object-relational database management system (ORDBMS) based on PostgreSQL, developed by the PostgreSQL Global Development Group. It is intentionally designed as an enterprise grade and cloud native database.\nGetting Started   Feature overview   Undo   Log record for roll back modified data and transactions.  Multitenant   Single database instance runs on a server and serves multiple tenants.  Network based tablespace   Devide computing and storage functions in database through network based tablespace.   Multithread   The multithreaded database model enables server processes to execute as operating system threads in separate address spaces.  Recyclebin   Provide recycle bin to reserve dropped objects to prevent mistake.  DDL event tracking   Tracking, recording, publishing and subscribing DDL operations.   "}]